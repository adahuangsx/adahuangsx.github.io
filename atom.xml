<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ada.h</title>
  
  
  <link href="https://adahuangsx.github.io/atom.xml" rel="self"/>
  
  <link href="https://adahuangsx.github.io/"/>
  <updated>2022-11-20T08:04:49.227Z</updated>
  <id>https://adahuangsx.github.io/</id>
  
  <author>
    <name>Ada Huang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo Memo</title>
    <link href="https://adahuangsx.github.io/2022/11/20/hello-world/"/>
    <id>https://adahuangsx.github.io/2022/11/20/hello-world/</id>
    <published>2022-11-20T08:04:49.227Z</published>
    <updated>2022-11-20T08:04:49.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new|n <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h2 id="Tips-for-writing-blogs"><a href="#Tips-for-writing-blogs" class="headerlink" title="Tips for writing blogs"></a>Tips for writing blogs</h2><ul><li><p>Note that the images or other resources should be put in “/themes/…/images/“ in the first place, because the <code>hexo clean</code> will erase the “/public/“ folder. Meanwhile, <code>hexo g|generate</code> will generate all the resources into “/public/“.</p></li><li><p>The path of images should be as if in “/public/“ folder, which means the path looks like “/images/…/image.jpg”.</p></li><li><p>The path of images should replace special characters like spaces with “%20”.</p></li><li><p>Changing posts supports hot deployment, which means I do not need to run <code>hexo s</code> again, but changing other resources like images does not. </p></li><li><p>Remember to renew the source files in Github.</p></li></ul><h2 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server|s</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h2 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate|g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h2 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy|d</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h2&gt;&lt;figure class</summary>
      
    
    
    
    
    <category term="Hexo" scheme="https://adahuangsx.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>三、存储与检索</title>
    <link href="https://adahuangsx.github.io/2022/05/20/new-post/"/>
    <id>https://adahuangsx.github.io/2022/05/20/new-post/</id>
    <published>2022-05-20T06:34:49.000Z</published>
    <updated>2022-11-20T08:04:49.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>两大类存储引擎：日志结构（log-structured） 的存储引擎，以及 面向页面（page-oriented） 的存储引擎（例如 B 树）。</p><ul><li><p>日志<br>一个 仅追加（append-only） 的数据文件<br>写入非常快，但是搜索效率很低</p></li><li><p>索引<br>trade-off：加快了读查询的速度，但是每个索引都会拖慢写入速度</p></li></ul><h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><h3 id="hash-索引-–-内存里的键值数据（key-value-Data）-的索引"><a href="#hash-索引-–-内存里的键值数据（key-value-Data）-的索引" class="headerlink" title="hash 索引 – 内存里的键值数据（key-value Data） 的索引"></a>hash 索引 – 内存里的键值数据（key-value Data） 的索引</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://github.com/Vonng/ddia">DDIA 中文网页版</a></li><li><a href="https://www.bilibili.com/video/BV1x7411M7Sf?from=search&seid=15149782867482872906&spm_id_from=333.337.0.0"> MIT 6.824 Distributed Systems 的视频</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;两大类存储引擎：日志结构（log-structured） 的存储引擎，以及 面向页面（page-oriented） 的存储引擎（例如 B 树</summary>
      
    
    
    
    <category term="DDIA" scheme="https://adahuangsx.github.io/categories/DDIA/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="DDIA" scheme="https://adahuangsx.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>5-Computer Architecture</title>
    <link href="https://adahuangsx.github.io/2021/04/15/Architecture/"/>
    <id>https://adahuangsx.github.io/2021/04/15/Architecture/</id>
    <published>2021-04-15T13:08:31.000Z</published>
    <updated>2022-11-20T08:04:49.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Buses-in-Von-Neumann-Architecture-Unit-5-1"><a href="#Buses-in-Von-Neumann-Architecture-Unit-5-1" class="headerlink" title="Buses in Von Neumann Architecture (Unit 5.1)"></a>Buses in Von Neumann Architecture (Unit 5.1)</h2><p>3 Information flows (bus):</p><p><img src="/images/Nand2Tetris/VonNeumannBuses.png" alt="Information Flows"></p><h2 id="The-Fetch-Execute-Cycle-Unit-5-2"><a href="#The-Fetch-Execute-Cycle-Unit-5-2" class="headerlink" title="The Fetch-Execute Cycle (Unit 5.2)"></a>The Fetch-Execute Cycle (Unit 5.2)</h2><p><strong>The basic CPU loop:</strong></p><ul><li><strong>Fetch an Instruction</strong> from the <strong>Program Memory</strong></li><li><strong>Execute</strong> it.</li><li>Repeat this.</li></ul><h3 id="Fetching"><a href="#Fetching" class="headerlink" title="Fetching"></a>Fetching</h3><ul><li>Put the location of the next instruction in the Memory address input (Program Counter)</li><li>Get the instruction code by reading the contents at that Memory location</li></ul><h3 id="Program-Counter"><a href="#Program-Counter" class="headerlink" title="Program Counter"></a>Program Counter</h3><p><img src="/images/Nand2Tetris/Program%20Counter.png" alt="Program Counter"></p><h3 id="The-Fetch-Execute-Clash"><a href="#The-Fetch-Execute-Clash" class="headerlink" title="The Fetch-Execute Clash"></a>The Fetch-Execute Clash</h3><p>The instructions and data pieces are stored in a single memory, so there is a clash.</p><p><strong>Solution:</strong></p><p><img src="/images/Nand2Tetris/Clash%20Multiplexer.png"></p><p><strong>Simpler Solution (Harvard Architecture):</strong></p><p>To separate the data memory and program memory into 2 modules.<br>No need to switch between fetching and executing.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Buses-in-Von-Neumann-Architecture-Unit-5-1&quot;&gt;&lt;a href=&quot;#Buses-in-Von-Neumann-Architecture-Unit-5-1&quot; class=&quot;headerlink&quot; title=&quot;Buses in</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>project4</title>
    <link href="https://adahuangsx.github.io/2021/04/06/project4/"/>
    <id>https://adahuangsx.github.io/2021/04/06/project4/</id>
    <published>2021-04-06T08:16:07.000Z</published>
    <updated>2022-11-20T08:04:49.229Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Write 2 programs in Hack Machine Language:</strong> </p><ol><li>a loop doing multiplication;</li><li>a listener for keyboard to blacken the screen.</li></ol><p>略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Write 2 programs in Hack Machine Language:&lt;/strong&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;a loop doing multiplication;&lt;/li&gt;
&lt;li&gt;a listener for keyboard t</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
    <category term="Projects" scheme="https://adahuangsx.github.io/tags/Projects/"/>
    
  </entry>
  
  <entry>
    <title>Hack Programming</title>
    <link href="https://adahuangsx.github.io/2021/03/13/Hack-programming/"/>
    <id>https://adahuangsx.github.io/2021/03/13/Hack-programming/</id>
    <published>2021-03-13T08:21:12.000Z</published>
    <updated>2022-11-20T08:04:49.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Working-with-Registers-and-Memory-Unit-4-6"><a href="#Working-with-Registers-and-Memory-Unit-4-6" class="headerlink" title="Working with Registers and Memory (Unit 4.6)"></a>Working with Registers and Memory (Unit 4.6)</h1><h3 id="Let’s-recall"><a href="#Let’s-recall" class="headerlink" title="Let’s recall"></a>Let’s recall</h3><ul><li>D: data register</li><li>A: address / data register </li><li>M: the currently selected memory register: <code>M = RAM[A]</code></li></ul><h3 id="Typical-operations"><a href="#Typical-operations" class="headerlink" title="Typical operations"></a>Typical operations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// D=10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D=A</span><br><span class="line"><span class="comment">// D++</span></span><br><span class="line">D=D+<span class="number">1</span></span><br><span class="line"><span class="comment">// D=RAM[17]</span></span><br><span class="line">@<span class="number">17</span></span><br><span class="line">D=M</span><br><span class="line"><span class="comment">// RAM[17]=D</span></span><br><span class="line">@<span class="number">17</span></span><br><span class="line">M=D</span><br><span class="line"><span class="comment">// RAM[17]=10</span></span><br><span class="line">@<span class="number">10</span></span><br><span class="line">D=A</span><br><span class="line">@<span class="number">17</span></span><br><span class="line">M=D</span><br><span class="line"><span class="comment">// RAM[5] = RAM[3]</span></span><br><span class="line">@<span class="number">3</span></span><br><span class="line">D=M</span><br><span class="line">@<span class="number">5</span></span><br><span class="line">M=D</span><br></pre></td></tr></table></figure><h2 id="How-to-end-the-program-properly"><a href="#How-to-end-the-program-properly" class="headerlink" title="How to end the program properly?"></a>How to end the program properly?</h2><p>The program will keep executing even if the instructions are run out (blank instructions). An evil hacker will put some uncontrollable codes to slide the flow of control to a memory area they can control.</p><p>This attack is called <strong>NOP slide</strong>, Null Instructions or Null Opcodes. </p><p>Note that the computer can never stand still. It is always doing something even when the keyboard is idle. There are many processes running in the back ground. <strong>A good practice</strong> is to end everything in the program with an infinite loop, like:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">@<span class="number">4</span>     // A - <span class="string">&quot;4&quot;</span> because this <span class="literal">line</span> <span class="keyword">is</span> ROM[<span class="number">4</span>]</span><br><span class="line"><span class="number">0</span>;JMP  // <span class="string">&quot;0&quot;</span> <span class="keyword">is</span> always <span class="string">&quot;== 0&quot;</span>, so it <span class="keyword">is</span> stuck <span class="keyword">in</span> these <span class="number">2</span> lines.</span><br></pre></td></tr></table></figure><hr><h2 id="Build-in-Symbols"><a href="#Build-in-Symbols" class="headerlink" title="Build-in Symbols"></a>Build-in Symbols</h2><h3 id="virtual-registers"><a href="#virtual-registers" class="headerlink" title="virtual registers"></a>virtual registers</h3><p>Hack has 16 virtual registers from <code>R0</code> to <code>R15</code>. They have exactly the same value as its position: <code>R5</code> has the value of <code>5</code>. </p><p><strong>The reason</strong> we need this is: the A-instruction has 2 functionalities, so it may get confusing sometimes. We will not know if it is an address or a number until seeing the next instructions. Therefore, we give it different labels:</p><p>![](D:\Winter 20\blog\themes\wikitten\source\images\Nand2Tetris\why virtual registers.png) </p><p>PS: Hack is case-sensitive. “R5” != “r5”</p><h3 id="Base-Addresses-of-I-O-Maps"><a href="#Base-Addresses-of-I-O-Maps" class="headerlink" title="Base Addresses of I/O Maps"></a>Base Addresses of I/O Maps</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCREEN   <span class="number">16384</span></span><br><span class="line">KBD      <span class="number">24576</span></span><br></pre></td></tr></table></figure><h3 id="Remaining-symbols"><a href="#Remaining-symbols" class="headerlink" title="Remaining symbols"></a>Remaining symbols</h3><p>They are used in the implementation of the Hack virtual machine.</p><hr><h1 id="Branching"><a href="#Branching" class="headerlink" title="Branching"></a>Branching</h1><p>The code of branching is taught in the C-instruction <code>jump</code> unit.</p><p>To make the Hack assembly code more readable, we introduce the label. (就是代码块的跳转标记). Its syntax is:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LABEL</span><span class="comment">// use the label</span></span><br><span class="line">D;JGT</span><br><span class="line">...</span><br><span class="line">(LABEL) @<span class="number">233</span><span class="comment">// declare the label</span></span><br><span class="line">M=D</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>@LABEL</code> translates to <code>@n</code>, where  <code>n</code> is the instruction number following the (<code>LABEL</code>) declaration.</p><p>Similar to <code>goto</code>.</p><hr><h1 id="Variables-Unit-4-7"><a href="#Variables-Unit-4-7" class="headerlink" title="Variables (Unit 4.7)"></a>Variables (Unit 4.7)</h1><p>In Hack, we only have 1 type of variables, which is 16-bit.</p><p> For example, there is a variable called “temp”:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Program: Flip.asm flips the values of RAM[0] and RAM[1]:</span></span><br><span class="line"><span class="comment">// temp = R1</span></span><br><span class="line"><span class="comment">// R1 = R0 </span></span><br><span class="line"><span class="comment">// R0 = temp</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">@temp</span></span><br><span class="line">M=D <span class="comment">// temp = R1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">@temp</span></span><br><span class="line">D=M</span><br><span class="line"><span class="meta">@R0</span></span><br><span class="line">M=D <span class="comment">// R0 = temp</span></span><br></pre></td></tr></table></figure><p><strong>That is how <code>@temp</code> works:</strong> Find some available register, and use it to represent the variable <code>temp</code>. So from now on, every occurrence of <code>@temp</code> will be translated into <code>@n</code>.</p><p>Another nice virtue is that the program is <strong>relocatable</strong> code, as long as the base address is known.</p><p><strong>Note:</strong> 怎么判断<code>@</code> 符操作是branching还是variable？<br>variable没有<code>(LABEL)</code> 这样的declaration，而branching一定有代码段中的标记。variable的声明在变量区。</p><hr><h1 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h1><p><strong>Recommended Tips:</strong></p><ul><li>Write Pseudo code first, then translate it into machine language;</li><li>Debug by simulating with <strong>trace table</strong>;</li></ul><hr><h1 id="Pointers-Unit-4-8"><a href="#Pointers-Unit-4-8" class="headerlink" title="Pointers (Unit 4.8)"></a>Pointers (Unit 4.8)</h1><p>![](D:\Winter 20\blog\themes\wikitten\source\images\Nand2Tetris\pointers in one slide.png)</p><p>The typical operation is <strong>the red instruction</strong>: set the address register to a given value. Before this unit, <code>A</code> is never on the left of the equation.</p><p><code>A = xx</code> 就可以看做是<code>@xx</code>，这样后面一行如果看到<code>M</code>，就更容易理解了。</p><hr><h1 id="Input-amp-Output"><a href="#Input-amp-Output" class="headerlink" title="Input &amp; Output"></a>Input &amp; Output</h1><h2 id="Example-Rectangle-Drawing"><a href="#Example-Rectangle-Drawing" class="headerlink" title="Example: Rectangle Drawing"></a>Example: Rectangle Drawing</h2><h3 id="Coding-Practice"><a href="#Coding-Practice" class="headerlink" title="Coding Practice:"></a>Coding Practice:</h3><p>赋值常数给变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SCREEN</span></span><br><span class="line">D=A</span><br><span class="line"><span class="meta">@addr</span></span><br><span class="line">M=D</span><br><span class="line"><span class="comment">// addr = 16384</span></span><br></pre></td></tr></table></figure><p>赋值简单的值（如初始化）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@i</span></span><br><span class="line">M=<span class="number">0</span></span><br><span class="line"><span class="comment">// i = 0   </span></span><br><span class="line"><span class="comment">// ??? 为什么不是RAM[i] = 0?</span></span><br><span class="line"><span class="comment">// 解答：i在这里是变量，自动分配一个地址，比如n，给这个变量。所以现在i表示的是n那个数字。</span></span><br></pre></td></tr></table></figure><p>取地址赋值（唯一的A在等式左边）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@addr</span> <span class="comment">// A = addr</span></span><br><span class="line">A=M<span class="comment">// 此时M为RAM[addr], 即@RAM[addr]</span></span><br><span class="line">M=-<span class="number">1</span><span class="comment">// *addr = -1</span></span><br><span class="line"><span class="comment">// RAM[addr] = 1111111111111111</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Working-with-Registers-and-Memory-Unit-4-6&quot;&gt;&lt;a href=&quot;#Working-with-Registers-and-Memory-Unit-4-6&quot; class=&quot;headerlink&quot; title=&quot;Working </summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>Input and Output</title>
    <link href="https://adahuangsx.github.io/2021/03/10/input-and-output/"/>
    <id>https://adahuangsx.github.io/2021/03/10/input-and-output/</id>
    <published>2021-03-10T09:58:42.000Z</published>
    <updated>2022-11-20T08:04:49.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Input-and-Output-Unit-4-5"><a href="#Input-and-Output-Unit-4-5" class="headerlink" title="Input and Output (Unit 4.5)"></a>Input and Output (Unit 4.5)</h1><p>We will learn to use bits to manipulate the peripheral devices.</p><h2 id="Screen-Memory-Map"><a href="#Screen-Memory-Map" class="headerlink" title="Screen Memory Map"></a>Screen Memory Map</h2><p>There is a display unit (256 * 512, b/w)</p><p>The <strong>Screen Memory Map</strong> is a sequence of 16-bit values, each of which is called “a word”. Altogether we have 8k (8192), 16-bit words, because there should be this much bits (one for each pixel).</p><p><strong>Note that</strong> the read/write operations are only 16-bit, not individual bits.</p><h3 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h3><p>We are going to implement the memory map with a chip called <strong>Screen</strong>. It’s an 8k chip, behaving exactly as a memory unit.</p><p>When we build the overall computer, this chip will be part of the data memory (or RAM). In other words, Screen is only one chip among a bunch of other chips.</p><p>To access the Screen chip in RAM, the addressing needs to add the base address (say, 16384). </p><h3 id="How-to-set-a-pixel"><a href="#How-to-set-a-pixel" class="headerlink" title="How to set a pixel"></a>How to set a pixel</h3><p>To set a pixel (<code>row</code>, <code>col</code>) on or off:</p><ol><li><code>word = Screen[32 * row + col / 16]</code><br><code>word = RAM[16384 + 32 * row + col / 16]</code></li><li>Set the <code>col % 16</code> -th bit of <code>word</code> to zero or one.</li><li>Commit <code>word</code> to RAM</li></ol><hr><h2 id="Keyboard-Memory-Map"><a href="#Keyboard-Memory-Map" class="headerlink" title="Keyboard Memory Map"></a>Keyboard Memory Map</h2><p>This is the chip which a physical keyboard is associated with. Its memory map needs no more than 16 bits, which is a single register. Every key has an agreed-upon value as a scan code.</p><p>When I lift my finger or the keyboard is idle, the memory map returns <strong>zero</strong>.</p><p>In Hack computer, it is in <code>RAM[24576]</code>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Input-and-Output-Unit-4-5&quot;&gt;&lt;a href=&quot;#Input-and-Output-Unit-4-5&quot; class=&quot;headerlink&quot; title=&quot;Input and Output (Unit 4.5)&quot;&gt;&lt;/a&gt;Input and</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>Machine Language</title>
    <link href="https://adahuangsx.github.io/2021/03/06/Machine-Language/"/>
    <id>https://adahuangsx.github.io/2021/03/06/Machine-Language/</id>
    <published>2021-03-06T05:08:42.000Z</published>
    <updated>2022-11-20T08:04:49.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview-Unit-4-1"><a href="#Overview-Unit-4-1" class="headerlink" title="Overview (Unit 4.1)"></a>Overview (Unit 4.1)</h2><p><strong>Alan Turing</strong> raised the idea of <strong>Universality</strong> and considered the theoretical model.</p><p>This idea was turned into practice by <strong>Von Neumann</strong>, who built the first serious architecture of a general computing machine.</p><h2 id="How-the-Instructions-look-in-a-computer"><a href="#How-the-Instructions-look-in-a-computer" class="headerlink" title="How the Instructions look in a computer"></a>How the Instructions look in a computer</h2><p><code>0100010 0011 0010</code></p><p><code>     ADD   R3   R2</code> :     Add R3 to R2</p><hr><h2 id="Memory-Hierarchy"><a href="#Memory-Hierarchy" class="headerlink" title="Memory Hierarchy"></a>Memory Hierarchy</h2><p>Accessing memory directly could be costly, because the addresses are long, and getting a value from a large bulk of memory is very slow compared to the CPU speed.</p><p>Therefore, instead of just having a large block of memory, we do it in a whole sequence of memories that get bigger and bigger.</p><p><strong>Register</strong> (Data Registers, Address Registers) -&gt; <strong>Cache</strong> -&gt; <strong>Main Memory</strong> -&gt; <strong>Disk</strong></p><hr><h2 id="Hack-Computer"><a href="#Hack-Computer" class="headerlink" title="Hack Computer"></a>Hack Computer</h2><h3 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h3><p><img src="/images/Nand2Tetris/hackHardware.png" alt="Hardware Structure"></p><p>Say, this is a 16-bit computer:</p><ul><li>Data memory (<strong>RAM</strong>): a sequence of 16-bit registers<ul><li><code>RAM[0], RAM[1], RAM[2],</code>… </li></ul></li><li>Instruction memory (<strong>ROM</strong>, read-only): a sequence of 16-bit registers: <ul><li><code>ROM[0], ROM[1], ROM[2],</code>… </li></ul></li><li>Central Processing Unit (CPU): performs 16-bit instructions </li><li><strong>Buses</strong>: Instruction bus / data bus / address buses</li></ul><h3 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h3><p><strong>Hack program</strong> is sequence of instructions written by the Hack machine language.</p><p><strong>Hack Machine Language:</strong></p><ul><li>16-bit A-instructions</li><li>16-bit C-instructions</li></ul><h3 id="How-does-the-program-run-Control"><a href="#How-does-the-program-run-Control" class="headerlink" title="How does the program run? (Control)"></a>How does the program run? (Control)</h3><ol><li>The Hack program loads in the ROM;</li><li><code>reset</code> button is pushed;</li><li>The program start running.</li></ol><h3 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h3><p>The Hack computer recognizes 3 registers:</p><ul><li>D: used to store data</li><li>A: used to store data / address the memory </li><li>M: represents the currently addressed memory register: <code>M = RAM[A]</code></li></ul><hr><h2 id="The-A-instruction-Syntax"><a href="#The-A-instruction-Syntax" class="headerlink" title="The A-instruction Syntax"></a>The A-instruction Syntax</h2><p><code>@value</code> means (1) set the register to the value <code>value</code>; (2) select the register <code>reg[value]</code>, or the M register above.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Set RAM[100] to -1</span><br><span class="line">@100  # A &#x3D; 100</span><br><span class="line">M &#x3D; -1  #RAM[100] &#x3D; -1</span><br></pre></td></tr></table></figure><p>Because A is for “addressing”.</p><h3 id="Binary-Syntax"><a href="#Binary-Syntax" class="headerlink" title="Binary Syntax"></a>Binary Syntax</h3><p>The number after ampersand “@” is a small non-negative number ($0 ~ 2^15 - 1$).</p><p>So, the “@” becomes <strong>a leading zero</strong> in Binary syntax.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># @21 would be</span><br><span class="line">0 00000 00000 10101</span><br></pre></td></tr></table></figure><hr><h2 id="The-C-instruction-Syntax"><a href="#The-C-instruction-Syntax" class="headerlink" title="The C-instruction Syntax"></a>The C-instruction Syntax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest &#x3D; comp; jump</span><br></pre></td></tr></table></figure><p>![C-instruction Syntax]/images/Nand2Tetris/C-instruction%20Syntax.png)</p><p><strong>Note:</strong></p><ol><li>Compute the value of <code>comp</code>, and store it into <code>dest</code>;</li><li><code>jump</code> represents comparing with <strong>zero</strong>;</li><li><code>JMP</code> means unconditional jump. A convention is do <code>0; jmp</code>, and this is an unconditional jump;</li><li>If the Boolean Expression (<code>comp jump 0</code>) is true, then jump to execute the next instruction stored in RAM[A];</li><li>Remember to “address” the register first.</li></ol><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Sets RAM[300] to the value of the D register plus 1</span><br><span class="line">@300 # A &#x3D; 300</span><br><span class="line">M&#x3D;D+1 # RAM[300] &#x3D; D + 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># If (D-1 &#x3D;&#x3D; 0) jumps to execute the instruction stored in ROM[56]</span><br><span class="line">@56 # A &#x3D; 56</span><br><span class="line">D-1;JEQ # if (D-1 &#x3D;&#x3D; 0) goto to instruction ROM[A]</span><br></pre></td></tr></table></figure><h3 id="Binary-Syntax-1"><a href="#Binary-Syntax-1" class="headerlink" title="Binary Syntax"></a>Binary Syntax</h3><p><img src="/images/Nand2Tetris/C-instruction%20Binary%20Syntax.png" alt="C-instruction Binary Syntax"></p><p>The complete specification is:</p><p><img src="/images/Nand2Tetris/C-instruction%20Specification.png" alt="C-instruction Specification"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Overview-Unit-4-1&quot;&gt;&lt;a href=&quot;#Overview-Unit-4-1&quot; class=&quot;headerlink&quot; title=&quot;Overview (Unit 4.1)&quot;&gt;&lt;/a&gt;Overview (Unit 4.1)&lt;/h2&gt;&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>Project 3: Sequential Chips</title>
    <link href="https://adahuangsx.github.io/2021/02/12/project3/"/>
    <id>https://adahuangsx.github.io/2021/02/12/project3/</id>
    <published>2021-02-12T06:52:35.000Z</published>
    <updated>2022-11-20T08:04:49.228Z</updated>
    
    <content type="html"><![CDATA[<p>​    We are going to implement  8 chips in this project.</p><h2 id="The-Chips-to-implement"><a href="#The-Chips-to-implement" class="headerlink" title="The Chips to implement"></a>The Chips to implement</h2><h3 id="1-Bit-Register-Chip"><a href="#1-Bit-Register-Chip" class="headerlink" title="1-Bit Register Chip"></a>1-Bit Register Chip</h3><p><strong>Tip:</strong> It can be built from a DFF and a multiplexor.</p><hr><h3 id="16-Bit-Register"><a href="#16-Bit-Register" class="headerlink" title="16-Bit Register"></a>16-Bit Register</h3><p><strong>Tip:</strong> A little bit different wiring from the last one.</p><hr><h3 id="8-Register-Chip"><a href="#8-Register-Chip" class="headerlink" title="8-Register Chip"></a>8-Register Chip</h3><p>This is the first RAM device consisting of 8 registers. Here is its API:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CHIP RAM8 &#123;</span><br><span class="line"><span class="keyword">IN</span> <span class="keyword">in</span>[<span class="number">16</span>], load, address[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">OUT</span> <span class="keyword">out</span>[<span class="number">16</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips:</strong></p><ol><li>We need to feed the <code>in</code> value to all the 8 registers simultaneously. </li><li>Then use the Mux or DeMux chips to select the one to operate.</li></ol><hr><h3 id="RAM64-RAM512-RAM4K-RAM16K"><a href="#RAM64-RAM512-RAM4K-RAM16K" class="headerlink" title="RAM64, RAM512, RAM4K,RAM16K"></a>RAM64, RAM512, RAM4K,RAM16K</h3><p><strong>Tips:</strong></p><p>As we started the last RAM8, we can stack the small RAM chip to larger ones, grouping them layer by layer.</p><p>Think about the <code>address</code> input as consisting of 2 fields: one to select the RAM, the other to select the register.</p><hr><h3 id="Program-Counter"><a href="#Program-Counter" class="headerlink" title="Program Counter"></a>Program Counter</h3><p><strong>Tip:</strong> It can be built from a register, an incrementor and other taught gates.</p><hr><hr><h2 id="Some-Questions"><a href="#Some-Questions" class="headerlink" title="Some Questions"></a>Some Questions</h2><p><strong>Q. Why there are 2 folders <code>a/</code> and <code>b/</code> in Project 3 directory?</strong></p><p>A. The larger RAMs, like RAM16K, are built from smaller ones down to the Bit Register, so it will involves a huge recursion. This will be too much for a humble simulator to handle. Therefore, we are supposed to use the built-in Java implementations, which makes it faster and smoother.</p><p><strong>Q. We take the Flip Flop as a black box in this course. How is it implemented in real?</strong></p><p>A. The core is 2 NAND Gates connected in a loop. A change in a moment can decide the output in the future. </p><p><img src="/images/Nand2Tetris/flipflopInner.png" alt="How DFF remembers data"></p><p>Above shows how gate maintains “memory”. Of course the outer layer is necessary for the DFF functionality.</p><hr><hr><h2 id="While-Doing-It"><a href="#While-Doing-It" class="headerlink" title="While Doing It"></a>While Doing It</h2><ul><li>HDL is a description language not a programming language. It is OK to input a new pin name, which appears in the line below, to <strong>implement the circle</strong> between gates. </li></ul><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><ul><li><a href="https://www.nand2tetris.org/project03">Project 3 Main page</a></li><li><a href="https://drive.google.com/file/d/1dPj4XNby9iuAs-47U9k3xtYy9hJ-ET0T/view">The HDL Guide</a></li><li><a href="https://drive.google.com/file/d/1IsDnH0t7q_Im491LQ7_5_ajV0CokRbwR/view">The Hack Chip Set API</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    We are going to implement  8 chips in this project.&lt;/p&gt;
&lt;h2 id=&quot;The-Chips-to-implement&quot;&gt;&lt;a href=&quot;#The-Chips-to-implement&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
    <category term="Projects" scheme="https://adahuangsx.github.io/tags/Projects/"/>
    
  </entry>
  
  <entry>
    <title>Memory Units</title>
    <link href="https://adahuangsx.github.io/2021/02/10/Memory-Units/"/>
    <id>https://adahuangsx.github.io/2021/02/10/Memory-Units/</id>
    <published>2021-02-10T05:08:42.000Z</published>
    <updated>2022-11-20T08:04:49.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Memory-Units-Unit-3-3"><a href="#Memory-Units-Unit-3-3" class="headerlink" title="Memory Units (Unit 3.3)"></a>Memory Units (Unit 3.3)</h1><p>Given the 1-bit register we learned in the last post, we can build more things!</p><h2 id="The-basic-memory-element-Register"><a href="#The-basic-memory-element-Register" class="headerlink" title="The basic memory element: Register"></a>The basic memory element: Register</h2><p><img src="/images/Nand2Tetris/16BitRegister.png" alt="16-bit Register"></p><ul><li>We use 16-bit <strong>word width</strong> to keep generality</li><li>“Word width” is a parameter <code>w</code>, which can be 32-bit, 64-bit, too.</li></ul><p><strong>Register’s State:</strong> the value which is currently stored in the register.</p><hr><h3 id="Read-Logic"><a href="#Read-Logic" class="headerlink" title="Read Logic"></a>Read Logic</h3><p>This is easy, just probe the <code>out</code> and see the outputs.</p><h3 id="Write-Logic"><a href="#Write-Logic" class="headerlink" title="Write Logic"></a>Write Logic</h3><p>Say, we want the register to remember the number <code>123</code>. We can:</p><ol><li>set <code>in = 123</code></li><li>set <code>load = 1</code></li><li>The <code>out</code> will emit <code>123</code> from the next time unit.</li></ol><hr><h3 id="How-in-the-Hardware-Simulator"><a href="#How-in-the-Hardware-Simulator" class="headerlink" title="How in the Hardware Simulator?"></a>How in the Hardware Simulator?</h3><ol><li>Load in the HDL file <code>nand2tetris\tools\builtInChips\DRegister.hdl</code>.</li><li>See the key word <code>BUILTIN</code> and <code>CLOCKED</code>. This chip is actually implemented by a Java class. When the key word <code>CLOCKED</code> is detected, the clock-shaped button will be activated.</li><li>The “Time: __” will tick to “0+” and then tock to “1”. The GUI “D: “ on the right displays the value of DFF (defaulted “0”). However, the output pin takes a complete cycle to emit the newly loaded value.</li></ol><hr><h2 id="RAM-Unit"><a href="#RAM-Unit" class="headerlink" title="RAM Unit"></a>RAM Unit</h2><p><img src="/images/Nand2Tetris/RAMunit.png" alt="RAM Unit"></p><ul><li>Abstractly, we view RAM unit as a sequence of $n$ addressable registers, with address <code>0</code> to <code>n - 1</code>.</li><li>At any point of time, only one register can be selected no matter how many registers exist.</li><li>To represent the address input, it should be $k$ long, where $k = \log_2 n$.</li><li>$n$ has nothing to do with the word width $w$.</li><li><strong>In a word,</strong> RAM is a sequential chip, and it depends on a clock input.</li></ul><h3 id="Read-amp-Write-Logic"><a href="#Read-amp-Write-Logic" class="headerlink" title="Read &amp; Write Logic"></a>Read &amp; Write Logic</h3><p>The same as a single register, except switching the address code.</p><hr><h2 id="A-family-of-16-bit-RAM-chips"><a href="#A-family-of-16-bit-RAM-chips" class="headerlink" title="A family of 16-bit RAM chips"></a>A family of 16-bit RAM chips</h2><p>The family has the same generic architecture as showed above.</p><p>As the number of registers, $n$, goes up, the chips are RAM8, RAM64, RAM32, RAM4K, RAM16K… Accordingly, $k$ is respectively 3, 6, 9, 12, 14…</p><p><strong>Why these 5 particular RAM chips?</strong></p><p>Stay tuned… we need them for the next Hack Computer.</p><hr><h3 id="Why-“Random-Access”"><a href="#Why-“Random-Access”" class="headerlink" title="Why “Random Access”?"></a>Why “Random Access”?</h3><p>RAM stands for “Random Access Memory”, because a magic thing is, once the address code is provide, no matter how many registers, 8 or 8 million, the data is accessible after the same moment.</p><hr><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><p>The computer needs a <strong>Program Counter (PC)</strong>  to keep track of the instruction which should be fetched and executed next.</p><p>The PC contains the address of the instruction to fetch.</p><h3 id="3-control-settings"><a href="#3-control-settings" class="headerlink" title="3 control settings:"></a>3 control settings:</h3><ol><li><strong>Reset:</strong> fetch the first instruction        <code>pc = 0</code></li><li><strong>Next:</strong> fetch the next instruction <code>pc++</code></li><li><strong>Goto:</strong> fetch instruction <code>n</code>          <code>pc = n</code></li></ol><h3 id="Inputs-amp-Outputs"><a href="#Inputs-amp-Outputs" class="headerlink" title="Inputs &amp; Outputs"></a>Inputs &amp; Outputs</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IN</span> <span class="keyword">in</span>[<span class="number">16</span>], laod, inc, reset;</span><br><span class="line"><span class="keyword">OUT</span> <span class="keyword">out</span>[<span class="number">16</span>];</span><br></pre></td></tr></table></figure><h3 id="Chip-Logic"><a href="#Chip-Logic" class="headerlink" title="Chip Logic"></a>Chip Logic</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (reset[t] == <span class="number">1</span>)</span><br><span class="line">out[t + <span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// reseting the counter</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (load[t] == <span class="number">1</span>)</span><br><span class="line">    out[t + <span class="number">1</span>] = in[t]; <span class="comment">// set the counter to input value</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (inc[t] == <span class="number">1</span>)</span><br><span class="line">    out[t + <span class="number">1</span>]++;    <span class="comment">// increment the counter</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    out[t + <span class="number">1</span>] = out[t];</span><br></pre></td></tr></table></figure><h3 id="How-in-the-Hardware-Simulator-1"><a href="#How-in-the-Hardware-Simulator-1" class="headerlink" title="How in the Hardware Simulator?"></a>How in the Hardware Simulator?</h3><ol><li>Load in  the HDL file <code>nand2tetris\tools\builtInChips\PC.hdl</code>.</li><li>Note the priority: <code>reset</code> first, then <code>load</code>, <code>inc</code> at last.</li><li>The <code>&gt;&gt;</code> button can tick the clock automatically every second. </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Memory-Units-Unit-3-3&quot;&gt;&lt;a href=&quot;#Memory-Units-Unit-3-3&quot; class=&quot;headerlink&quot; title=&quot;Memory Units (Unit 3.3)&quot;&gt;&lt;/a&gt;Memory Units (Unit 3.</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>Hello, Time!</title>
    <link href="https://adahuangsx.github.io/2021/02/08/Hello-Time/"/>
    <id>https://adahuangsx.github.io/2021/02/08/Hello-Time/</id>
    <published>2021-02-08T08:06:54.000Z</published>
    <updated>2022-11-20T08:04:49.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sequential-Logic-Unit-3-1"><a href="#Sequential-Logic-Unit-3-1" class="headerlink" title="Sequential Logic (Unit 3.1)"></a>Sequential Logic (Unit 3.1)</h2><p>In this unit we introduce the issue of <strong>time</strong> into the system, since we didn’t have the <u>notion of change</u> before. To simplify the concept, we divide time into atomic pieces, which is <strong>clock</strong>.</p><h3 id="Clock-Integer-Time-Unit"><a href="#Clock-Integer-Time-Unit" class="headerlink" title="Clock (Integer Time Unit)"></a>Clock (Integer Time Unit)</h3><p>Clock can be viewed as an oscillator at a certain fixed rate, of which each cycle is treated as a time unit, like time 0, time 1 and so on.</p><p>The signals are viewed as a indivisible thing <strong>as if nothing changes within each time unit</strong>. As a input signal is renewed every cycle, the output signal instantaneously follows (几乎同时). </p><p><strong>You may wonder if this is real.</strong> Indeed, there may be delay in physical electrical signals. But, we can think it as a way that <strong>the voltage change</strong> (the grey area in the screenshot below) <strong>happens between cycles</strong>, while luckily, the cycles are a little bit wider than this instability. So, it is safe to ignore it and focus on the end of each time unit. </p><p><img src="/images/Nand2Tetris/theClock.png"></p><p>Also, (my guess) <strong>another reason</strong> may be given by the answer “Why binary?”. —&gt; it may takes time to reach the final and consistent stage but not necessarily precise but it’s already enough to tell zero from one.</p><h3 id="Combinatorial-Logic-Vs-Sequential-Logic"><a href="#Combinatorial-Logic-Vs-Sequential-Logic" class="headerlink" title="Combinatorial Logic Vs. Sequential Logic"></a>Combinatorial Logic Vs. Sequential Logic</h3><p>Combinatorial:<br>$$<br>out[t] = function(in[t])<br>$$<br>Above is what we learned in the previous units.</p><p>Sequential:<br>$$<br>out[t] = function(in[t - 1])<br>$$<br>This is what we are going to talk about next.</p><hr><p>The above topic requires an element: <strong>Remembering State</strong>, so that the time unit <code>t</code> can response according to time unit <code>t - 1</code>.</p><p>That means it has to be in two different physical states, which must be able to <strong>shift</strong> according to the logic of the previous time unit.</p><h2 id="Flip-Flops-触发器-Unit-3-2"><a href="#Flip-Flops-触发器-Unit-3-2" class="headerlink" title="Flip Flops(触发器) (Unit 3.2)"></a>Flip Flops(触发器) (Unit 3.2)</h2><p>Gates that can <strong>flip</strong> between 2 gates —&gt; Flip Flops</p><h3 id="D-Flip-Flop"><a href="#D-Flip-Flop" class="headerlink" title="D Flip Flop"></a>D Flip Flop</h3><p><img src="/images/Nand2Tetris/SequentialChip.png" alt="The Clocked Data Flip Flop or &quot;D Flip Flop&quot; (即D触发器)"></p><ul><li>The little triangle represents this is a sequential chip.</li><li>It is primitive in this course, like Nand Gate, the base of all other gates.</li><li>It can be built from Nand Gate.</li><li>It is a simple gate with “memory”.</li></ul><h3 id="How-to-build-the-D-Flip-Flop"><a href="#How-to-build-the-D-Flip-Flop" class="headerlink" title="How to build the D Flip Flop?"></a>How to build the D Flip Flop?</h3><p><strong>Steps:</strong></p><ol><li>Create a loop which amplifying the same signal.</li><li>Provide isolation between sequential time units.</li><li>再多的实现部分也不会在这个课上讲了……</li></ol><h3 id="Remember-Forever"><a href="#Remember-Forever" class="headerlink" title="Remember Forever"></a>Remember Forever</h3><p>把D触发器输出连回到输入，就能实现数据的维持了。在回去的时候通过一些Combinatorial Logic就能进行其他计算的操作了。</p><p>这个可以进一步整合成一个“register”。</p><hr><h2 id="1-Bit-Register"><a href="#1-Bit-Register" class="headerlink" title="1-Bit Register"></a>1-Bit Register</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (load(t - 1) &#x3D;&#x3D; true)</span><br><span class="line">out(t) &#x3D; in(t - 1) &#x2F;&#x2F; Load in </span><br><span class="line">else</span><br><span class="line">out(t) &#x3D; out(t - 1) &#x2F;&#x2F; maintain</span><br></pre></td></tr></table></figure><p><img src="/images/Nand2Tetris/registerImple.png" alt="1-Bit Chip Implementation"></p><hr><p>Once we work out the 1-bit memory, we can build the much larger memory.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Sequential-Logic-Unit-3-1&quot;&gt;&lt;a href=&quot;#Sequential-Logic-Unit-3-1&quot; class=&quot;headerlink&quot; title=&quot;Sequential Logic (Unit 3.1)&quot;&gt;&lt;/a&gt;Sequentia</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>Project 2: Boolean Arithmetic</title>
    <link href="https://adahuangsx.github.io/2021/02/07/project2/"/>
    <id>https://adahuangsx.github.io/2021/02/07/project2/</id>
    <published>2021-02-07T01:38:22.000Z</published>
    <updated>2022-11-20T08:04:49.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Previous-Topic"><a href="#Previous-Topic" class="headerlink" title="Previous Topic"></a>Previous Topic</h2><p>The previous post has elaborated 3 things we need to implement: <strong>Half Adder</strong>, <strong>Full Adder</strong> and <strong>16-bit Number Adder</strong>. The next is a simpler one: <strong>16-bit Incrementor</strong>.</p><h2 id="Other-Two-Chips"><a href="#Other-Two-Chips" class="headerlink" title="Other Two Chips"></a>Other Two Chips</h2><h3 id="16-bit-Incrementor"><a href="#16-bit-Incrementor" class="headerlink" title="16-bit Incrementor"></a>16-bit Incrementor</h3><p><strong>Tip:</strong> A single bit “0” or “1” can be represented by <code>true</code> or <code>false</code> in HDL.</p><h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><p><strong>Tips:</strong> </p><ol><li>This can be built with the chips in Project 1</li><li>Only less than 20 lines of HDL code are needed.</li><li>No need to use my own implementation in Project 1, but instead, the best practice is to use their built-in versions. <ul><li>(Make sure to use them like “Mux” or “And” precisely, because the simulator always looks for the chips in the current directory, and then if finds nothing, it will kick in and use the automatic built-in version at last.)</li></ul></li></ol><hr><h2 id="Some-Questions-This-Week"><a href="#Some-Questions-This-Week" class="headerlink" title="Some Questions This Week"></a>Some Questions This Week</h2><p><strong>Q. We have built nearly 20 chips. Are they standard? or are they typically used in the computer systems?</strong><br>A. Yes, the gates this week like Half Adder and Full Adder are standard, as well as the 16 chips built in the last project like “Mux” and “Xor”, except ALU, which is extremely simplified from the actually used one. So, this ALU is a bit unique among usual ALUs.</p><p><strong>Q. How does the ALU we built operates multiplication and division?</strong><br>A. There is no problem to write HDL code that specifies chips to carry out these operations by working directly on bits. In fact, there are some elegant algorithms to do that. Designers are free to decide how much functionality to put into each layers. In this course, we put multiplication and division into the software that runs on the top of the computer to keep ALU simple.</p><p>Also, this is another trade-off since hardware functionality runs much faster but costly. However, the high-level programmers will not feel this difference.</p><p><strong>Q. Is the ALU efficient?</strong><br>A. Almost everything we build is efficient, but some optimization is still possible. For example, the adder. Say there is a 32-bit adder, and to compute all the 32 bits, we need to connect all of the 32 Full Adders with the carries along the significance ladder. </p><p>But don’t forget that a Full Adder is made of 3-4 other chips. So, the total <strong>delay</strong> would be $32 * 3 $. One optimization is the carry that goes one of the Full Adders at the top. We can, instead, compute this MSB carry in a more efficient way. This is called <strong>“carry look ahead”</strong>.</p><p><strong>Q. Why using the built-in chips, not the ones we built in the Project 1?</strong><br>A. You are more than welcomed to use them. However, using built-in chips is good for unit-testing and prevent the bugs from being messed up.    </p><hr><h2 id="While-doing-it-（感想及常见错误）"><a href="#While-doing-it-（感想及常见错误）" class="headerlink" title="While doing it （感想及常见错误）"></a>While doing it （感想及常见错误）</h2><p>这次的作业感觉就是上次的延伸。只有5个chip，而且是前4个adder层层递进。</p><p>最后一个ALU是难点，重要的是要把上一次作业的chips利用起来。比如对于<code>zx</code>或<code>nx</code>，如何通过一个bit是零还是壹而输出不同的值，则应该想到Mux（多路器）。</p><p>还有仍然要小心”sub-bus“的错误，那就是<code>[xx..xx]</code>只能出现在<code>..., out=out)</code> 中的等号左边而不能pipe到其他chip的<code>(in=...,)</code>里，而形如<code>..., out=out[0..7])</code>则会报<code>Sub bus of an internal node may not be used</code>的错误。例子如下：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SomeGate(..., <span class="keyword">out</span>=foo);</span><br><span class="line">Or8Way(<span class="keyword">in</span>=foo[<span class="number">0</span>..<span class="number">7</span>], <span class="keyword">out</span>=p1);</span><br><span class="line">Or8Way(<span class="keyword">in</span>=foo[<span class="number">8</span>..<span class="number">15</span>], <span class="keyword">out</span>=p2); // <span class="literal">ERROR</span></span><br></pre></td></tr></table></figure><p>这样是不对的，因为<code>foo</code>是个中间产生的变量名，它在HDL中不能用sub-bus的方式作为另一个chip的“in=”。</p><p>Instead，</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SomeGate(..., <span class="keyword">out</span>[<span class="number">0</span>..<span class="number">7</span>]=foo1);</span><br><span class="line">SomeGate(..., <span class="keyword">out</span>[<span class="number">8</span>..<span class="number">15</span>]=foo2);</span><br><span class="line">Or8Way(<span class="keyword">in</span>=foo1, <span class="keyword">out</span>=p1);</span><br><span class="line">Or8Way(<span class="keyword">in</span>=foo2, <span class="keyword">out</span>=p2);</span><br></pre></td></tr></table></figure><p>应该像上面这样把2个narrower buses分别输出。代码的意思是“foo1接收了out的[0..7]位并被赋值成了8-bit的值”。</p><p>也可以像这样把多个narrowing合并起来：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SomeGate(..., <span class="keyword">out</span>[<span class="number">0</span>..<span class="number">7</span>]=foo1, <span class="keyword">out</span>[<span class="number">8</span>..<span class="number">15</span>]=foo2);</span><br></pre></td></tr></table></figure><p>以上可以参照<a href="https://www.nand2tetris.org/hdl-survival-guide">Survival Guide</a> 中的“sub-busing”部分。</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><ul><li><a href="https://www.nand2tetris.org/project02">Project 2 Main page</a></li><li><a href="https://drive.google.com/file/d/1dPj4XNby9iuAs-47U9k3xtYy9hJ-ET0T/view">The HDL Guide</a></li><li><a href="https://drive.google.com/file/d/1IsDnH0t7q_Im491LQ7_5_ajV0CokRbwR/view">The Hack Chip Set API</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Previous-Topic&quot;&gt;&lt;a href=&quot;#Previous-Topic&quot; class=&quot;headerlink&quot; title=&quot;Previous Topic&quot;&gt;&lt;/a&gt;Previous Topic&lt;/h2&gt;&lt;p&gt;The previous post has </summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
    <category term="Projects" scheme="https://adahuangsx.github.io/tags/Projects/"/>
    
  </entry>
  
  <entry>
    <title>Arithmetic Logic Unit (ALU)</title>
    <link href="https://adahuangsx.github.io/2021/02/06/Binary-ALU/"/>
    <id>https://adahuangsx.github.io/2021/02/06/Binary-ALU/</id>
    <published>2021-02-06T01:26:15.000Z</published>
    <updated>2022-11-20T08:04:49.224Z</updated>
    
    <content type="html"><![CDATA[<p>Adding two numbers in binary representation is pretty simple. Here we are gonna build an Adder for binary numbers.</p><h1 id="Starter-Unit-2-2"><a href="#Starter-Unit-2-2" class="headerlink" title="Starter (Unit 2.2)"></a>Starter (Unit 2.2)</h1><h2 id="Why-does-the-Adder-matter-most"><a href="#Why-does-the-Adder-matter-most" class="headerlink" title="Why does the Adder matter most?"></a>Why does the Adder matter most?</h2><p><strong><u>Adder</strong> + Negative representation = <strong>Subtraction</strong></u></p><p><u><strong>Multiplication</strong> and <strong>Division</strong> are not hardware’s work, but software’s.</u></p><h2 id="Three-steps-to-build-an-Adder"><a href="#Three-steps-to-build-an-Adder" class="headerlink" title="Three steps to build an Adder"></a>Three steps to build an Adder</h2><ul><li>Half Adder: adds 2 bits</li><li>Full Adder: adds 3 bits (used in “carry a 1”)</li><li>Adder: adds 2 numbers</li></ul><h3 id="Half-Adder-adds-2-bits"><a href="#Half-Adder-adds-2-bits" class="headerlink" title="Half Adder: adds 2 bits"></a>Half Adder: adds 2 bits</h3><p>When we focus on a single slice of bits adding, like “1 + 1”, it has 2 outputs: a carry bit “1” and a result bit “0”.</p><table><thead><tr><th>a</th><th>b</th><th align="center">sum(Xor)</th><th align="center">carry(And)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td align="center">0</td><td align="center">0</td></tr><tr><td>0</td><td>1</td><td align="center">1</td><td align="center">0</td></tr><tr><td>1</td><td>0</td><td align="center">1</td><td align="center">0</td></tr><tr><td>1</td><td>1</td><td align="center">0</td><td align="center">1</td></tr></tbody></table><p><code>CHIP HalfAdder</code> is the first thing we need to implement in <strong>Project 2</strong>.</p><h3 id="Full-Adder-adds-3-bits"><a href="#Full-Adder-adds-3-bits" class="headerlink" title="Full Adder: adds 3 bits"></a>Full Adder: adds 3 bits</h3><p>The last <strong>Half Adder</strong> is only for the case when carry is “0”, while <strong>Full Adder</strong> includes adding the carry and 2 bits together.</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th align="right">sum</th><th align="right">carry</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td align="right">0</td><td align="right">0</td></tr><tr><td>0</td><td>0</td><td>1</td><td align="right">1</td><td align="right">0</td></tr><tr><td>0</td><td>1</td><td>0</td><td align="right">1</td><td align="right">0</td></tr><tr><td>0</td><td>1</td><td>1</td><td align="right">0</td><td align="right">1</td></tr><tr><td>1</td><td>0</td><td>0</td><td align="right">1</td><td align="right">0</td></tr><tr><td>1</td><td>0</td><td>1</td><td align="right">0</td><td align="right">1</td></tr><tr><td>1</td><td>1</td><td>0</td><td align="right">0</td><td align="right">1</td></tr><tr><td>1</td><td>1</td><td>1</td><td align="right">1</td><td align="right">1</td></tr></tbody></table><p><strong>Tip:</strong> A Full Adder can be built with 2 Half Adders.</p><h3 id="Adder-adds-2-numbers"><a href="#Adder-adds-2-numbers" class="headerlink" title="Adder: adds 2 numbers"></a>Adder: adds 2 numbers</h3><p>Assuming the numbers are <strong>16-bit long</strong>, we can implement it by connecting <u>16 Full Adders</u> or <u>15 Full Adders and 1 Half Adder</u> for the right-most bits.</p><p><strong>Tips:</strong></p><ol><li>The carry bit is “piped” up the significance ladder, from right to left.</li><li>The MSB carry bit should be ignored.</li></ol><hr><h2 id="Negative-Numbers"><a href="#Negative-Numbers" class="headerlink" title="Negative Numbers"></a>Negative Numbers</h2><p><strong>2’s complement</strong> is elegant, and it enables us to do subtraction (negative addition) exactly the same way as addition.</p><h3 id="Computing-“-x”"><a href="#Computing-“-x”" class="headerlink" title="Computing “-x”"></a>Computing “-x”</h3><p>By solving this, we can deal with subtraction! So, <strong>no more hardware needed</strong> for it!~<br>$$<br>-x = 2^n-x = 1 + (2^n - 1) - x<br>$$<br><strong>Why converting this way?</strong></p><p>Because $(2^n-1) $ is “all ones”, which makes subtraction very easy (no need to borrow anything!). —&gt; JUST FLIP THE BITS of $x$</p><p>Then, add one. —&gt; easy.</p><h2 id="Negation-steps-in-one-word"><a href="#Negation-steps-in-one-word" class="headerlink" title="Negation steps in one word:"></a>Negation steps in one word:</h2><ol><li>Flip all the bits;</li><li>Add one.</li></ol><hr><hr><h1 id="ALU-Unit-2-4"><a href="#ALU-Unit-2-4" class="headerlink" title="ALU (Unit 2.4)"></a>ALU (Unit 2.4)</h1><p>Where is ALU? Let’s take a close look into the computer:</p><h2 id="Von-Neumann-Architecture"><a href="#Von-Neumann-Architecture" class="headerlink" title="Von Neumann Architecture"></a>Von Neumann Architecture</h2><p>$$<br>Computer System = Input + Memory + (Control + ALU) + Output<br>$$</p><p>In which,<br>$$<br>Control + ALU = CPU (Central Processing Unit)<br>$$</p><hr><h2 id="The-Hack-ALU"><a href="#The-Hack-ALU" class="headerlink" title="The Hack ALU"></a>The Hack ALU</h2><p><img src="/images/Nand2Tetris/theHackALU.png" alt="What Control Bits represent"></p><p>The 6 control bits represent which function to compute. <code>zr</code> and <code>ng</code> will be clear later.</p><h2 id="Open-the-ALU-Black-Box"><a href="#Open-the-ALU-Black-Box" class="headerlink" title="Open the ALU Black Box"></a>Open the ALU Black Box</h2><p><strong>Control bits</strong> (blue circle in the last image):</p><ul><li><code>zx</code>    <code>if (zx) then x = 0</code></li><li><code>nx</code>    <code>if (nx) then x = !x</code></li><li><code>zy</code>    <code>if (zy) then y = 0</code></li><li><code>ny</code>    <code>if (zy) then y = !y</code></li><li><code>f</code>    <code>if (f) then out=x + y else out = x &amp; y</code></li><li><code>no</code>    <code>if (no) then out = !out</code></li></ul><p>These 6 control bits work one after another (按顺序进行操作).</p><p>比如<code>zx</code> 和 <code>nx</code>都是 “0”，那么就是让<code>x</code>不做任何操作，保持原样。<br>如果<code>zx</code> 是 <code>nx</code>都是 “1”，那么就是先转为 “0”，再取反，就是把<code>x</code>各位都转化为 “1”。</p><p><img src="/images/Nand2Tetris/theHackALUWhy.png" alt="Looking into the Control Bits"></p><h2 id="Some-Questions"><a href="#Some-Questions" class="headerlink" title="Some Questions"></a>Some Questions</h2><p>Q. How does this magically happened? It didn’t do the addition or subtraction as we learned earlier 0 0<br>A. We don’t want to get too much into it…</p><p>Q. 6 control bits can have $2^6 $ representations, why are there only 16 functions?<br>A. Try out some other combinations, you will find them produce nothing interesting.</p><p>Q. What are <code>zr</code> and <code>ng</code> designed for?<br>A. They are to say something about the main output <code>out</code>.</p><p><code>if (out == 0) then zr = 1 else zr = 0</code><br><code>if (out &lt; 0) then ng = 1 else ng = 0</code></p><hr><blockquote><p><strong>Simplicity is the ultimate sophistication.</strong> ——Leonardo da Vinci</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Adding two numbers in binary representation is pretty simple. Here we are gonna build an Adder for binary numbers.&lt;/p&gt;
&lt;h1 id=&quot;Starter-Un</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>Binary and Arithmetic</title>
    <link href="https://adahuangsx.github.io/2021/02/05/Binary-and-arithmetic/"/>
    <id>https://adahuangsx.github.io/2021/02/05/Binary-and-arithmetic/</id>
    <published>2021-02-05T11:08:31.000Z</published>
    <updated>2022-11-20T08:04:49.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-and-Arithmetic-Unit-2-1"><a href="#Binary-and-Arithmetic-Unit-2-1" class="headerlink" title="Binary and Arithmetic (Unit 2.1)"></a>Binary and Arithmetic (Unit 2.1)</h1><p>Adding two numbers in binary representation is pretty simple. Here we are gonna build an Adder for binary numbers.</p><h2 id="Why-does-the-Adder-matter-most"><a href="#Why-does-the-Adder-matter-most" class="headerlink" title="Why does the Adder matter most?"></a>Why does the Adder matter most?</h2><p><u><strong>Adder</strong> + Negative representation = <strong>Subtraction</strong></u></p><p><u><strong>Multiplication</strong> and <strong>Division</strong> are not hardware’s work, but software’s.</u></p><h2 id="Three-steps-to-build-an-Adder"><a href="#Three-steps-to-build-an-Adder" class="headerlink" title="Three steps to build an Adder"></a>Three steps to build an Adder</h2><ul><li>Half Adder: adds 2 bits</li><li>Full Adder: adds 3 bits (used in “carry a 1”)</li><li>Adder: adds 2 numbers</li></ul><h3 id="Half-Adder-adds-2-bits"><a href="#Half-Adder-adds-2-bits" class="headerlink" title="Half Adder: adds 2 bits"></a>Half Adder: adds 2 bits</h3><p>When we focus on a single slice of bits adding, like “1 + 1”, it has 2 outputs: a carry bit “1” and a result bit “0”.</p><p>(truth table)</p><p>(chip code)</p><p><code>CHIP HalfAdder</code> is the first thing we need to implement in <strong>Project 2</strong>.</p><h3 id="Full-Adder-adds-3-bits"><a href="#Full-Adder-adds-3-bits" class="headerlink" title="Full Adder: adds 3 bits"></a>Full Adder: adds 3 bits</h3><p>The last <strong>Half Adder</strong> is only for the case when carry is “0”, while <strong>Full Adder</strong> includes adding the carry and 2 bits together.</p><p>(truth table)</p><p>(chip code)</p><h3 id="Adder-adds-2-numbers"><a href="#Adder-adds-2-numbers" class="headerlink" title="Adder: adds 2 numbers"></a>Adder: adds 2 numbers</h3><p>Assuming the numbers are <strong>16-bit long</strong>, we can implement it by connecting <u>16 Full Adders</u> or <u>15 Full Adders and 1 Half Adder</u> for the right-most bits.</p><hr><h2 id="Negative-Numbers"><a href="#Negative-Numbers" class="headerlink" title="Negative Numbers"></a>Negative Numbers</h2><p><strong>2’s complement</strong> is elegant, and it enables us to do subtraction (negative addition) exactly the same way as addition.</p><h3 id="Computing-“-x”"><a href="#Computing-“-x”" class="headerlink" title="Computing “-x”"></a>Computing “-x”</h3><p>By solving this, we can deal with subtraction! So, <strong>no more hardware needed</strong> for it!~<br>$$<br>-x = 2^n-x = 1 + (2^n - 1) - x<br>$$<br><strong>Why converting this way?</strong></p><p>Because $(2^n-1) $ is “all ones”, which makes subtraction very easy (no need to borrow anything!). —&gt; JUST FLIP THE BITS</p><p>Then, add one. —&gt; easy.</p><h2 id="Negation-steps-in-one-word"><a href="#Negation-steps-in-one-word" class="headerlink" title="Negation steps in one word:"></a>Negation steps in one word:</h2><ol><li>Flip all the bits;</li><li>Add one.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Binary-and-Arithmetic-Unit-2-1&quot;&gt;&lt;a href=&quot;#Binary-and-Arithmetic-Unit-2-1&quot; class=&quot;headerlink&quot; title=&quot;Binary and Arithmetic (Unit 2.1)</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>Project 1: Boolean Logic</title>
    <link href="https://adahuangsx.github.io/2021/01/25/project1/"/>
    <id>https://adahuangsx.github.io/2021/01/25/project1/</id>
    <published>2021-01-25T14:08:14.000Z</published>
    <updated>2022-11-20T08:04:49.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Project-1-Goal-Unit-1-8"><a href="#Project-1-Goal-Unit-1-8" class="headerlink" title="Project 1 Goal (Unit 1.8)"></a>Project 1 Goal (Unit 1.8)</h2><p>Given a NAND, build all the gates.</p><p><img src="/images/Nand2Tetris/the-course-is-about.png" alt="上帝：“去造个计算机。”"></p><p>课上给了Project 1的其中几个chips的讲解。讲了Mux, DMux, And16 和 Mux4Way16。</p><hr><h2 id="Project-1-Overview"><a href="#Project-1-Overview" class="headerlink" title="Project 1 Overview"></a>Project 1 Overview</h2><h3 id="Multiplexor-多路器-or-Mux"><a href="#Multiplexor-多路器-or-Mux" class="headerlink" title="Multiplexor (多路器) or Mux"></a>Multiplexor (多路器) or Mux</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IN</span> a, b, sel  // <span class="string">&quot;sel&quot;</span> means <span class="string">&quot;selection bit&quot;</span>.</span><br><span class="line"><span class="keyword">OUT</span> <span class="keyword">out</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sel == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">out</span> = a</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">out</span> = b</span><br></pre></td></tr></table></figure><p><strong>Tip:</strong> You can build with AND, OR, NOT gates.</p><h4 id="Example-AndMuxOr"><a href="#Example-AndMuxOr" class="headerlink" title="Example: AndMuxOr"></a>Example: AndMuxOr</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IN</span> a, b, sel</span><br><span class="line"><span class="keyword">OUT</span> <span class="keyword">out</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sel == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">out</span> = a <span class="keyword">AND</span> b</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">out</span> = a <span class="keyword">OR</span> b</span><br></pre></td></tr></table></figure><p><strong>Tip:</strong> 这个可以很容易用<code>Mux</code>做出来。</p><hr><h3 id="Demultiplexor-分路器-or-DeMux"><a href="#Demultiplexor-分路器-or-DeMux" class="headerlink" title="Demultiplexor(分路器) or DeMux"></a>Demultiplexor(分路器) or DeMux</h3><p>It is like the “inverse” of Mux.</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IN</span> <span class="keyword">in</span>, sel</span><br><span class="line"><span class="keyword">OUT</span> a, b</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sel == <span class="number">0</span>)</span><br><span class="line">(a, b) = (<span class="keyword">in</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">(a, b) = (<span class="number">0</span>, <span class="keyword">in</span>)</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> 以上两个都在communication networks中经常使用。比如Mux和DMux之间就可能是一个海底光缆的单线信息流，两头分别进行汇总和分流。如下图：</p><p><img src="/images/Nand2Tetris/muxANDdmux.png" alt="Communication Networks"></p><p>这里的<code>sel</code>就是oscillator（振荡器）。</p><p>这样做可以减少昂贵的物理传输费用，还可以做到encoding和decoding异步进行。</p><hr><h3 id="And16"><a href="#And16" class="headerlink" title="And16"></a>And16</h3><p><strong>Tip:</strong> 16个bit是无顺序可言的，就像同时放出来的一样。</p><hr><h3 id="Mux4Way16"><a href="#Mux4Way16" class="headerlink" title="Mux4Way16"></a>Mux4Way16</h3><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IN</span> a[<span class="number">16</span>], b[<span class="number">16</span>], c[<span class="number">16</span>], d[<span class="number">16</span>], sel[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">OUT</span> <span class="keyword">out</span>[<span class="number">16</span>];</span><br><span class="line">// <span class="symbol">&#x27;sel</span>&#x27; has <span class="number">2</span> bits <span class="keyword">to</span> represent <span class="number">4</span> ways.</span><br></pre></td></tr></table></figure><hr><hr><h3 id="Some-tips-for-this-assignment"><a href="#Some-tips-for-this-assignment" class="headerlink" title="Some tips for this assignment"></a>Some tips for this assignment</h3><ul><li><p>尽量按顺序完成，这样后面的就可以用到前面写好的helper chips。</p></li><li><p>不按顺序也可以，但是当用到一个没写好的chip比如<code>chip AND &#123;&#125;</code>，可以把文件名临时改成<code>And.hdl233</code>。这样系统会自动调用内建的chip。</p></li><li><p>chip不能调用自己。</p></li><li><p>记得看HDL Survival Guide 和各种资源！</p></li><li><p>VSCode 居然有Nand2Tetris的专门编辑.hdl文件的插件。<br><img src="/images/Nand2Tetris/vscode.png"></p></li></ul><h3 id="Some-tips-when-doing-it"><a href="#Some-tips-when-doing-it" class="headerlink" title="Some tips when doing it"></a>Some tips when doing it</h3><ul><li>变量名不要用下划线！（别问我怎么知道的……）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://b1391bd6-da3d-477d-8c01-38cdf774495a.filesusr.com/ugd/44046b_bfd91435260748439493a60a8044ade6.pdf">Hardware Simulator Tutorial</a></li><li><a href="https://www.nand2tetris.org/hdl-survival-guide">HDL Survival Guide</a></li><li><a href="https://www.nand2tetris.org/project01">其他资源在这里，大都是google doc的</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Project-1-Goal-Unit-1-8&quot;&gt;&lt;a href=&quot;#Project-1-Goal-Unit-1-8&quot; class=&quot;headerlink&quot; title=&quot;Project 1 Goal (Unit 1.8)&quot;&gt;&lt;/a&gt;Project 1 Goal </summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
    <category term="Projects" scheme="https://adahuangsx.github.io/tags/Projects/"/>
    
  </entry>
  
  <entry>
    <title>Hardware simulator</title>
    <link href="https://adahuangsx.github.io/2021/01/23/hardware-simulator/"/>
    <id>https://adahuangsx.github.io/2021/01/23/hardware-simulator/</id>
    <published>2021-01-23T14:15:40.000Z</published>
    <updated>2022-11-20T08:04:49.227Z</updated>
    
    <content type="html"><![CDATA[<p>这两个单元主要是介绍了软件怎么用，怎么test和生成output。<br>简介了Hardware Description Language (HDL) (unit 1.4)</p><h2 id="Hardware-simulator-unit-1-5"><a href="#Hardware-simulator-unit-1-5" class="headerlink" title="Hardware simulator (unit 1.5)"></a>Hardware simulator (unit 1.5)</h2><h3 id="Feel-free-to-“kick-the-tires”"><a href="#Feel-free-to-“kick-the-tires”" class="headerlink" title="Feel free to “kick the tires”!"></a>Feel free to “kick the tires”!</h3><ul><li>The simulator is written in Java.</li><li>The download link is <a href="https://www.nand2tetris.org/software">here</a>.</li><li>The simulator is invoking in <code>nand2tetris/tools/HardwareSimulator.bat</code>.</li><li>It can check both output pins and internal pins.</li></ul><h3 id="Script-based-simulation"><a href="#Script-based-simulation" class="headerlink" title="Script-based simulation"></a>Script-based simulation</h3><p>HDL code <code>.hdl</code> + test script  <code>tst</code> —–&gt; into simulator —–&gt; Output file <code>.out</code></p><p><strong>Note that</strong> this way to debug by checking the output file is rare in real life testing, because a real chip is far more complex than an Xor chip. A more systematic and planned method is going to be introduced next.</p><h3 id="Script-based-simulation-with-compare-files"><a href="#Script-based-simulation-with-compare-files" class="headerlink" title="Script-based simulation with compare files"></a>Script-based simulation with compare files</h3><p>The compare file <code>.cmp</code>, whose previous incarnation (前身) is a correct output file.</p><hr><h2 id="Hardware-Construction-Projects"><a href="#Hardware-Construction-Projects" class="headerlink" title="Hardware Construction Projects"></a>Hardware Construction Projects</h2><ul><li><h3 id="System-architects"><a href="#System-architects" class="headerlink" title="System architects"></a>System architects</h3><ul><li>chip API</li><li>test script</li><li>compare file</li></ul></li><li><h3 id="Developers"><a href="#Developers" class="headerlink" title="Developers"></a>Developers</h3><ul><li>build the chip with HDL</li></ul></li></ul><p><strong>In this course, we play the role of developers.</strong></p><hr><h2 id="Multi-Bit-Buses"><a href="#Multi-Bit-Buses" class="headerlink" title="Multi-Bit Buses"></a>Multi-Bit Buses</h2><p><em>“Bus” means “many” in Latin.</em></p><h3 id="Some-Syntax-Notes"><a href="#Some-Syntax-Notes" class="headerlink" title="Some Syntax Notes"></a>Some Syntax Notes</h3><p>Say, an integer is <code>aaa[16]</code>:</p><ul><li><code>aaa</code> is the integer’s name</li><li><code>aaa[0]</code> is its first bit. （注意是LSB，就是最低位/最右边的一位。）</li><li><code>aaa[7..15]</code>, with 2 dots in the middle, means its sub-bus.</li></ul><p>Other syntaxes:</p><ul><li><code>true</code> and <code>false</code> can represent a bus with constant signal of any width.</li></ul><hr><p>补充一个后面答疑问到的几个关于HDL的问题：</p><p>Q. 这门课中的HDL语言是现实中使用的吗？<br>A. 很相似，比如和VHDL相比，VHDL可能在基本的HDL基础上加了一些类C的语言，比如For这些。（所以code block我也就近用了VHDL的高亮）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两个单元主要是介绍了软件怎么用，怎么test和生成output。&lt;br&gt;简介了Hardware Description Language (HDL) (unit 1.4)&lt;/p&gt;
&lt;h2 id=&quot;Hardware-simulator-unit-1-5&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>Why Nand? -- starting Nand2Tetris part I</title>
    <link href="https://adahuangsx.github.io/2021/01/23/Why-Nand/"/>
    <id>https://adahuangsx.github.io/2021/01/23/Why-Nand/</id>
    <published>2021-01-23T05:25:32.000Z</published>
    <updated>2022-11-20T08:04:49.226Z</updated>
    
    <content type="html"><![CDATA[<p>这一章除了复习了一遍以前学过的与非或逻辑门，还介绍了为什么一个<strong>与非门</strong>就能表示所有的逻辑表达式。</p><h1 id="Boolean-logic-unit-1-1-–-1-3"><a href="#Boolean-logic-unit-1-1-–-1-3" class="headerlink" title="Boolean logic (unit 1.1 – 1.3)"></a>Boolean logic (unit 1.1 – 1.3)</h1><h2 id="Algebra-rules"><a href="#Algebra-rules" class="headerlink" title="Algebra rules"></a>Algebra rules</h2><ul><li><p>Commutative laws</p><ul><li>x AND y == y AND x</li><li>x OR y == y OR x</li></ul></li><li><p>Associative laws</p><ul><li>x AND (y AND z) == (x AND y) AND z</li><li>x OR (y OR z) == (x OR y) OR z</li></ul></li><li><p>Distributive laws</p><ul><li>x <strong>AND</strong> (y OR z) == (x AND y) OR (x AND z)</li><li>x <strong>OR</strong> (y AND z) == (x OR y) AND (x OR z)</li></ul></li><li><p>De Morgan laws</p><ul><li>NOT (x AND y) == NOT (x) OR NOT (y)</li><li>NOT (x OR y) == NOT (x) AND NOT (y)</li></ul></li><li><p>Other rules</p><ul><li>x AND x == x</li><li>x OR x == x</li></ul></li></ul><h2 id="Truth-table-to-Boolean-Expression"><a href="#Truth-table-to-Boolean-Expression" class="headerlink" title="Truth table to Boolean Expression"></a>Truth table to Boolean Expression</h2><ol><li><p><strong>Focus all the “1” results</strong></p></li><li><p><strong>write down all the expressions which only apply to the single rows in the truth table</strong></p></li><li><p><strong>OR these expressions together</strong></p><p><img src="/images/Nand2Tetris/table2expression.png" alt="Truth table to Boolean Expression"></p></li><li><p><strong>Simplify it.</strong></p><p>In the example above, give a close look at the first two clauses: we have both possibilities for “y” and the same fixed value for “x”. So, we can combine the two clauses, which does not ask about y and only ask about “NOT(x)” and “NOT(z)”.</p><p>Then keep doing this.</p><p><img src="/images/Nand2Tetris/simplify%20expression.png" alt="Simplify it"></p><p><strong>Note that</strong> finding the shortest expressions is not easy for humans nor for algorithms, because this is a NP-hard problem.</p></li></ol><hr><h2 id="To-prove-Why-Nand"><a href="#To-prove-Why-Nand" class="headerlink" title="To prove Why-Nand"></a>To prove Why-Nand</h2><h3 id="The-Theorem"><a href="#The-Theorem" class="headerlink" title="The Theorem"></a>The Theorem</h3><p>Any Boolean function can be represented using an expression only containing AND and NOT operations.</p><p>Then, we introduce the NAND gate, which is proved to be the <strong>only needed gates</strong>.</p><h3 id="Here-comes-the-Nand"><a href="#Here-comes-the-Nand" class="headerlink" title="Here comes the Nand"></a>Here comes the Nand</h3><p>x NAND y == NOT (x AND y)</p><p><u><em>“NAND” is short for “NOT AND”.</em></u></p><h3 id="Nand-takes-over"><a href="#Nand-takes-over" class="headerlink" title="Nand takes over."></a>Nand takes over.</h3><ol><li>NOT (x) == x NAND x</li><li>x AND y == NOT (x NAND y)</li></ol><hr><p>The gate interface in unique. There is only one way to describe its functionality. Meantime, there are multiple implementations that realize the same obstruction. This duality of <strong>“one obstruction, many different implementations”</strong> is very typical in Computer Science.</p><p>所以这里解答了我对计算机的一个疑问，那就是不必纠结一个复杂的功能最底层到底是怎么实现的，而是像这门课一样，分层地理解。了解了一层以后，就把这层的知识作为已知，再去了解上面一层。</p><hr><p>补充一个后面答疑问到的几个关于Nand的问题：</p><p>Q. 用NAND以外别的gate做计算机的基础行不行？<br>A. 当然可以，比如<code>NOR (NOT OR)</code>。这就像物理中用不同的坐标系一样。只不过NAND相比于其他gate造价相对便宜。</p><p>Q. 这门课直接把Nand拿来用，但是黑盒里面是怎么实现的呢？<br>A. 这更像是一个物理问题，不属于这门课的范围。但是很容易举出一个实现的例子：<a href="https://www.51dzw.com/embed/embed_83634.html">用NMOS实现与非门电路</a></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><blockquote><ul><li><a href="https://www.nand2tetris.org/">Nand2Tetris home page</a></li><li><a href="https://www.coursera.org/learn/build-a-computer">Nand2Tetris Coursera link</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一章除了复习了一遍以前学过的与非或逻辑门，还介绍了为什么一个&lt;strong&gt;与非门&lt;/strong&gt;就能表示所有的逻辑表达式。&lt;/p&gt;
&lt;h1 id=&quot;Boolean-logic-unit-1-1-–-1-3&quot;&gt;&lt;a href=&quot;#Boolean-logic-unit-1</summary>
      
    
    
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/categories/Nand2Tetris/"/>
    
    
    <category term="Notes" scheme="https://adahuangsx.github.io/tags/Notes/"/>
    
    <category term="Coursera" scheme="https://adahuangsx.github.io/tags/Coursera/"/>
    
    <category term="Nand2Tetris" scheme="https://adahuangsx.github.io/tags/Nand2Tetris/"/>
    
  </entry>
  
  <entry>
    <title>IR Project -- Movie Script Search</title>
    <link href="https://adahuangsx.github.io/2020/12/10/IS2140-IR-finalproject/"/>
    <id>https://adahuangsx.github.io/2020/12/10/IS2140-IR-finalproject/</id>
    <published>2020-12-10T06:28:28.000Z</published>
    <updated>2022-11-20T08:04:49.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>This is the final project of INFSCI 2140 Information Storage and Retrieval. We built a search engine of movie lines. Users can input a phrase or a complete sentence and it returns a list of best matched movies with excerpts.</p><h3 id="Teammates"><a href="#Teammates" class="headerlink" title="Teammates"></a>Teammates</h3><ul><li>Zijian Xu</li><li>Long Yan</li></ul><h1 id="Data-Source"><a href="#Data-Source" class="headerlink" title="Data Source"></a>Data Source</h1><p><a href="https://nlds.soe.ucsc.edu/fc2">https://nlds.soe.ucsc.edu/fc2</a> Film Corpus 2.0 </p><p>It contains 960 film scripts including dialogues and scene descriptions.</p><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><ul><li>Backend: Spring MVC</li><li>Frontend: Angular 7</li><li>Cloud &amp; Deployment: Microsoft Azure Cloud</li><li>Library: Apache Lucene</li></ul><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="Data-Processing"><a href="#Data-Processing" class="headerlink" title="Data Processing"></a>Data Processing</h2><ol><li>Remove space lines and special characters</li><li>Tokenize and normalize the terms with Porter Stemming</li></ol><h2 id="Data-Pipeline"><a href="#Data-Pipeline" class="headerlink" title="Data Pipeline"></a>Data Pipeline</h2><p><img src="/images/IRProject/data%20pipeline.png" alt="Data Pipeline"></p><ul><li><p>Indexing – Index Writer</p><ul><li>Fetch movie script documents from cloud </li><li>Write index files with Lucene into RAM</li><li>Run once with starting the server</li></ul></li><li><p>Searching – Index Reader</p><ul><li>Tokenize query words</li><li>Search for the documents with Lucene</li><li>Get surrogate fragments with Lucene highlighter</li></ul></li></ul><h1 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h1><p>Users input a phrase or sentence like “show me the money”, and our system outputs:</p><p><img src="/images/IRProject/usecase.png" alt="Searching results"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><h4 id="Film-Corpus"><a href="#Film-Corpus" class="headerlink" title="Film Corpus"></a>Film Corpus</h4><ul><li><p>Walker, Marilyn A., Ricky Grant, Jennifer Sawyer, Grace I. Lin, Noah Wardrip-Fruin, and Michael Buell. “<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.380.9026&rep=rep1&type=pdf">Perceived or Not Perceived: Film Character Models for Expressive NLG</a>.” BEST PAPER AWARD. In <em>International Conference on Interactive Digital Storytelling (ICIDS), Vancouver, Canada, 2011.</em></p></li><li><p>Marilyn A. Walker, Grace I. Lin, Jennifer E. Sawyer. “<a href="http://www.lrec-conf.org/proceedings/lrec2012/pdf/1114_Paper.pdf">An Annotated Corpus of Film Dialogue for Learning and Characterizing Character Style</a>.” In <em>Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC), Istanbul, Turkey, 2012.</em></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;This is the final project of I</summary>
      
    
    
    
    <category term="Projects" scheme="https://adahuangsx.github.io/categories/Projects/"/>
    
    
    <category term="Search Engine" scheme="https://adahuangsx.github.io/tags/Search-Engine/"/>
    
    <category term="Java" scheme="https://adahuangsx.github.io/tags/Java/"/>
    
    <category term="Spring MVC" scheme="https://adahuangsx.github.io/tags/Spring-MVC/"/>
    
    <category term="Projects" scheme="https://adahuangsx.github.io/tags/Projects/"/>
    
  </entry>
  
</feed>
