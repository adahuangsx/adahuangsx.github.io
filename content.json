{"meta":{"title":"Ada.h","subtitle":"","description":"","author":"Ada Huang","url":"https://adahuangsx.github.io","root":"/"},"pages":[{"title":"Categories","date":"2022-11-20T08:04:49.230Z","updated":"2022-11-20T08:04:49.230Z","comments":true,"path":"categories/index.html","permalink":"https://adahuangsx.github.io/categories/index.html","excerpt":"","text":"Cat index.md"},{"title":"Tags","date":"2022-11-20T08:04:49.230Z","updated":"2022-11-20T08:04:49.230Z","comments":true,"path":"tags/index.html","permalink":"https://adahuangsx.github.io/tags/index.html","excerpt":"","text":""},{"title":"MY RESUME","date":"2022-12-18T01:39:55.723Z","updated":"2022-12-18T01:39:55.723Z","comments":true,"path":"about/index.html","permalink":"https://adahuangsx.github.io/about/index.html","excerpt":"","text":"更多请见：我的领英主页"}],"posts":[{"title":"Hexo Memo","slug":"hello-world","date":"2022-11-20T08:04:49.227Z","updated":"2022-11-20T08:04:49.227Z","comments":true,"path":"2022/11/20/hello-world/","link":"","permalink":"https://adahuangsx.github.io/2022/11/20/hello-world/","excerpt":"","text":"Create a new post1$ hexo new|n &quot;My New Post&quot; More info: Writing Tips for writing blogs Note that the images or other resources should be put in “/themes/…/images/“ in the first place, because the hexo clean will erase the “/public/“ folder. Meanwhile, hexo g|generate will generate all the resources into “/public/“. The path of images should be as if in “/public/“ folder, which means the path looks like “/images/…/image.jpg”. The path of images should replace special characters like spaces with “%20”. Changing posts supports hot deployment, which means I do not need to run hexo s again, but changing other resources like images does not. Remember to renew the source files in Github. Run server1$ hexo server|s More info: Server Generate static files1$ hexo generate|g More info: Generating Deploy to remote sites1$ hexo deploy|d More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://adahuangsx.github.io/tags/Hexo/"}]},{"title":"三、存储与检索","slug":"new-post","date":"2022-05-20T06:34:49.000Z","updated":"2022-11-20T08:04:49.227Z","comments":true,"path":"2022/05/20/new-post/","link":"","permalink":"https://adahuangsx.github.io/2022/05/20/new-post/","excerpt":"","text":"引言两大类存储引擎：日志结构（log-structured） 的存储引擎，以及 面向页面（page-oriented） 的存储引擎（例如 B 树）。 日志一个 仅追加（append-only） 的数据文件写入非常快，但是搜索效率很低 索引trade-off：加快了读查询的速度，但是每个索引都会拖慢写入速度 索引结构hash 索引 – 内存里的键值数据（key-value Data） 的索引参考资料 DDIA 中文网页版 MIT 6.824 Distributed Systems 的视频","categories":[{"name":"DDIA","slug":"DDIA","permalink":"https://adahuangsx.github.io/categories/DDIA/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"DDIA","slug":"DDIA","permalink":"https://adahuangsx.github.io/tags/DDIA/"}]},{"title":"5-Computer Architecture","slug":"Architecture","date":"2021-04-15T13:08:31.000Z","updated":"2022-11-20T08:04:49.224Z","comments":true,"path":"2021/04/15/Architecture/","link":"","permalink":"https://adahuangsx.github.io/2021/04/15/Architecture/","excerpt":"","text":"Buses in Von Neumann Architecture (Unit 5.1)3 Information flows (bus): The Fetch-Execute Cycle (Unit 5.2)The basic CPU loop: Fetch an Instruction from the Program Memory Execute it. Repeat this. Fetching Put the location of the next instruction in the Memory address input (Program Counter) Get the instruction code by reading the contents at that Memory location Program Counter The Fetch-Execute ClashThe instructions and data pieces are stored in a single memory, so there is a clash. Solution: Simpler Solution (Harvard Architecture): To separate the data memory and program memory into 2 modules.No need to switch between fetching and executing.","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"project4","slug":"project4","date":"2021-04-06T08:16:07.000Z","updated":"2022-11-20T08:04:49.229Z","comments":true,"path":"2021/04/06/project4/","link":"","permalink":"https://adahuangsx.github.io/2021/04/06/project4/","excerpt":"","text":"Write 2 programs in Hack Machine Language: a loop doing multiplication; a listener for keyboard to blacken the screen. 略","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"},{"name":"Projects","slug":"Projects","permalink":"https://adahuangsx.github.io/tags/Projects/"}]},{"title":"Hack Programming","slug":"Hack-programming","date":"2021-03-13T08:21:12.000Z","updated":"2022-11-20T08:04:49.225Z","comments":true,"path":"2021/03/13/Hack-programming/","link":"","permalink":"https://adahuangsx.github.io/2021/03/13/Hack-programming/","excerpt":"","text":"Working with Registers and Memory (Unit 4.6)Let’s recall D: data register A: address / data register M: the currently selected memory register: M = RAM[A] Typical operations123456789101112131415161718192021// D=10@10D=A// D++D=D+1// D=RAM[17]@17D=M// RAM[17]=D@17M=D// RAM[17]=10@10D=A@17M=D// RAM[5] = RAM[3]@3D=M@5M=D How to end the program properly?The program will keep executing even if the instructions are run out (blank instructions). An evil hacker will put some uncontrollable codes to slide the flow of control to a memory area they can control. This attack is called NOP slide, Null Instructions or Null Opcodes. Note that the computer can never stand still. It is always doing something even when the keyboard is idle. There are many processes running in the back ground. A good practice is to end everything in the program with an infinite loop, like: 12345.........@4 // A - &quot;4&quot; because this line is ROM[4]0;JMP // &quot;0&quot; is always &quot;== 0&quot;, so it is stuck in these 2 lines. Build-in Symbolsvirtual registersHack has 16 virtual registers from R0 to R15. They have exactly the same value as its position: R5 has the value of 5. The reason we need this is: the A-instruction has 2 functionalities, so it may get confusing sometimes. We will not know if it is an address or a number until seeing the next instructions. Therefore, we give it different labels: ![](D:\\Winter 20\\blog\\themes\\wikitten\\source\\images\\Nand2Tetris\\why virtual registers.png) PS: Hack is case-sensitive. “R5” != “r5” Base Addresses of I/O Maps12SCREEN 16384KBD 24576 Remaining symbolsThey are used in the implementation of the Hack virtual machine. BranchingThe code of branching is taught in the C-instruction jump unit. To make the Hack assembly code more readable, we introduce the label. (就是代码块的跳转标记). Its syntax is: 123456 @LABEL // use the label D;JGT ...(LABEL) @233 // declare the label M=D ... @LABEL translates to @n, where n is the instruction number following the (LABEL) declaration. Similar to goto. Variables (Unit 4.7)In Hack, we only have 1 type of variables, which is 16-bit. For example, there is a variable called “temp”: 123456789101112// Program: Flip.asm flips the values of RAM[0] and RAM[1]:// temp = R1// R1 = R0 // R0 = temp...@tempM=D // temp = R1...@tempD=M@R0M=D // R0 = temp That is how @temp works: Find some available register, and use it to represent the variable temp. So from now on, every occurrence of @temp will be translated into @n. Another nice virtue is that the program is relocatable code, as long as the base address is known. Note: 怎么判断@ 符操作是branching还是variable？variable没有(LABEL) 这样的declaration，而branching一定有代码段中的标记。variable的声明在变量区。 IterationRecommended Tips: Write Pseudo code first, then translate it into machine language; Debug by simulating with trace table; Pointers (Unit 4.8)![](D:\\Winter 20\\blog\\themes\\wikitten\\source\\images\\Nand2Tetris\\pointers in one slide.png) The typical operation is the red instruction: set the address register to a given value. Before this unit, A is never on the left of the equation. A = xx 就可以看做是@xx，这样后面一行如果看到M，就更容易理解了。 Input &amp; OutputExample: Rectangle DrawingCoding Practice:赋值常数给变量： 12345@SCREEND=A@addrM=D// addr = 16384 赋值简单的值（如初始化）： 12345@iM=0// i = 0 // ??? 为什么不是RAM[i] = 0?// 解答：i在这里是变量，自动分配一个地址，比如n，给这个变量。所以现在i表示的是n那个数字。 取地址赋值（唯一的A在等式左边）： 1234@addr // A = addrA=M // 此时M为RAM[addr], 即@RAM[addr]M=-1 // *addr = -1// RAM[addr] = 1111111111111111","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"Input and Output","slug":"input-and-output","date":"2021-03-10T09:58:42.000Z","updated":"2022-11-20T08:04:49.227Z","comments":true,"path":"2021/03/10/input-and-output/","link":"","permalink":"https://adahuangsx.github.io/2021/03/10/input-and-output/","excerpt":"","text":"Input and Output (Unit 4.5)We will learn to use bits to manipulate the peripheral devices. Screen Memory MapThere is a display unit (256 * 512, b/w) The Screen Memory Map is a sequence of 16-bit values, each of which is called “a word”. Altogether we have 8k (8192), 16-bit words, because there should be this much bits (one for each pixel). Note that the read/write operations are only 16-bit, not individual bits. ScreenWe are going to implement the memory map with a chip called Screen. It’s an 8k chip, behaving exactly as a memory unit. When we build the overall computer, this chip will be part of the data memory (or RAM). In other words, Screen is only one chip among a bunch of other chips. To access the Screen chip in RAM, the addressing needs to add the base address (say, 16384). How to set a pixelTo set a pixel (row, col) on or off: word = Screen[32 * row + col / 16]word = RAM[16384 + 32 * row + col / 16] Set the col % 16 -th bit of word to zero or one. Commit word to RAM Keyboard Memory MapThis is the chip which a physical keyboard is associated with. Its memory map needs no more than 16 bits, which is a single register. Every key has an agreed-upon value as a scan code. When I lift my finger or the keyboard is idle, the memory map returns zero. In Hack computer, it is in RAM[24576].","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"Machine Language","slug":"Machine-Language","date":"2021-03-06T05:08:42.000Z","updated":"2022-11-20T08:04:49.226Z","comments":true,"path":"2021/03/06/Machine-Language/","link":"","permalink":"https://adahuangsx.github.io/2021/03/06/Machine-Language/","excerpt":"","text":"Overview (Unit 4.1)Alan Turing raised the idea of Universality and considered the theoretical model. This idea was turned into practice by Von Neumann, who built the first serious architecture of a general computing machine. How the Instructions look in a computer0100010 0011 0010 ADD R3 R2 : Add R3 to R2 Memory HierarchyAccessing memory directly could be costly, because the addresses are long, and getting a value from a large bulk of memory is very slow compared to the CPU speed. Therefore, instead of just having a large block of memory, we do it in a whole sequence of memories that get bigger and bigger. Register (Data Registers, Address Registers) -&gt; Cache -&gt; Main Memory -&gt; Disk Hack ComputerHardware Say, this is a 16-bit computer: Data memory (RAM): a sequence of 16-bit registers RAM[0], RAM[1], RAM[2],… Instruction memory (ROM, read-only): a sequence of 16-bit registers: ROM[0], ROM[1], ROM[2],… Central Processing Unit (CPU): performs 16-bit instructions Buses: Instruction bus / data bus / address buses SoftwareHack program is sequence of instructions written by the Hack machine language. Hack Machine Language: 16-bit A-instructions 16-bit C-instructions How does the program run? (Control) The Hack program loads in the ROM; reset button is pushed; The program start running. RegistersThe Hack computer recognizes 3 registers: D: used to store data A: used to store data / address the memory M: represents the currently addressed memory register: M = RAM[A] The A-instruction Syntax@value means (1) set the register to the value value; (2) select the register reg[value], or the M register above. Example: 123# Set RAM[100] to -1@100 # A &#x3D; 100M &#x3D; -1 #RAM[100] &#x3D; -1 Because A is for “addressing”. Binary SyntaxThe number after ampersand “@” is a small non-negative number ($0 ~ 2^15 - 1$). So, the “@” becomes a leading zero in Binary syntax. 12# @21 would be0 00000 00000 10101 The C-instruction Syntax1dest &#x3D; comp; jump ![C-instruction Syntax]/images/Nand2Tetris/C-instruction%20Syntax.png) Note: Compute the value of comp, and store it into dest; jump represents comparing with zero; JMP means unconditional jump. A convention is do 0; jmp, and this is an unconditional jump; If the Boolean Expression (comp jump 0) is true, then jump to execute the next instruction stored in RAM[A]; Remember to “address” the register first. Example: 123# Sets RAM[300] to the value of the D register plus 1@300 # A &#x3D; 300M&#x3D;D+1 # RAM[300] &#x3D; D + 1 123# If (D-1 &#x3D;&#x3D; 0) jumps to execute the instruction stored in ROM[56]@56 # A &#x3D; 56D-1;JEQ # if (D-1 &#x3D;&#x3D; 0) goto to instruction ROM[A] Binary Syntax The complete specification is:","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"Project 3: Sequential Chips","slug":"project3","date":"2021-02-12T06:52:35.000Z","updated":"2022-11-20T08:04:49.228Z","comments":true,"path":"2021/02/12/project3/","link":"","permalink":"https://adahuangsx.github.io/2021/02/12/project3/","excerpt":"","text":"​ We are going to implement 8 chips in this project. The Chips to implement1-Bit Register ChipTip: It can be built from a DFF and a multiplexor. 16-Bit RegisterTip: A little bit different wiring from the last one. 8-Register ChipThis is the first RAM device consisting of 8 registers. Here is its API: 1234CHIP RAM8 &#123; IN in[16], load, address[3]; OUT out[16];&#125; Tips: We need to feed the in value to all the 8 registers simultaneously. Then use the Mux or DeMux chips to select the one to operate. RAM64, RAM512, RAM4K,RAM16KTips: As we started the last RAM8, we can stack the small RAM chip to larger ones, grouping them layer by layer. Think about the address input as consisting of 2 fields: one to select the RAM, the other to select the register. Program CounterTip: It can be built from a register, an incrementor and other taught gates. Some QuestionsQ. Why there are 2 folders a/ and b/ in Project 3 directory? A. The larger RAMs, like RAM16K, are built from smaller ones down to the Bit Register, so it will involves a huge recursion. This will be too much for a humble simulator to handle. Therefore, we are supposed to use the built-in Java implementations, which makes it faster and smoother. Q. We take the Flip Flop as a black box in this course. How is it implemented in real? A. The core is 2 NAND Gates connected in a loop. A change in a moment can decide the output in the future. Above shows how gate maintains “memory”. Of course the outer layer is necessary for the DFF functionality. While Doing It HDL is a description language not a programming language. It is OK to input a new pin name, which appears in the line below, to implement the circle between gates. Reference Project 3 Main page The HDL Guide The Hack Chip Set API","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"},{"name":"Projects","slug":"Projects","permalink":"https://adahuangsx.github.io/tags/Projects/"}]},{"title":"Memory Units","slug":"Memory-Units","date":"2021-02-10T05:08:42.000Z","updated":"2022-11-20T08:04:49.226Z","comments":true,"path":"2021/02/10/Memory-Units/","link":"","permalink":"https://adahuangsx.github.io/2021/02/10/Memory-Units/","excerpt":"","text":"Memory Units (Unit 3.3)Given the 1-bit register we learned in the last post, we can build more things! The basic memory element: Register We use 16-bit word width to keep generality “Word width” is a parameter w, which can be 32-bit, 64-bit, too. Register’s State: the value which is currently stored in the register. Read LogicThis is easy, just probe the out and see the outputs. Write LogicSay, we want the register to remember the number 123. We can: set in = 123 set load = 1 The out will emit 123 from the next time unit. How in the Hardware Simulator? Load in the HDL file nand2tetris\\tools\\builtInChips\\DRegister.hdl. See the key word BUILTIN and CLOCKED. This chip is actually implemented by a Java class. When the key word CLOCKED is detected, the clock-shaped button will be activated. The “Time: __” will tick to “0+” and then tock to “1”. The GUI “D: “ on the right displays the value of DFF (defaulted “0”). However, the output pin takes a complete cycle to emit the newly loaded value. RAM Unit Abstractly, we view RAM unit as a sequence of $n$ addressable registers, with address 0 to n - 1. At any point of time, only one register can be selected no matter how many registers exist. To represent the address input, it should be $k$ long, where $k = \\log_2 n$. $n$ has nothing to do with the word width $w$. In a word, RAM is a sequential chip, and it depends on a clock input. Read &amp; Write LogicThe same as a single register, except switching the address code. A family of 16-bit RAM chipsThe family has the same generic architecture as showed above. As the number of registers, $n$, goes up, the chips are RAM8, RAM64, RAM32, RAM4K, RAM16K… Accordingly, $k$ is respectively 3, 6, 9, 12, 14… Why these 5 particular RAM chips? Stay tuned… we need them for the next Hack Computer. Why “Random Access”?RAM stands for “Random Access Memory”, because a magic thing is, once the address code is provide, no matter how many registers, 8 or 8 million, the data is accessible after the same moment. CounterThe computer needs a Program Counter (PC) to keep track of the instruction which should be fetched and executed next. The PC contains the address of the instruction to fetch. 3 control settings: Reset: fetch the first instruction pc = 0 Next: fetch the next instruction pc++ Goto: fetch instruction n pc = n Inputs &amp; Outputs12IN in[16], laod, inc, reset;OUT out[16]; Chip Logic12345678if (reset[t] == 1) out[t + 1] = 0; // reseting the counterelse if (load[t] == 1) out[t + 1] = in[t]; // set the counter to input valueelse if (inc[t] == 1) out[t + 1]++; // increment the counterelse out[t + 1] = out[t]; How in the Hardware Simulator? Load in the HDL file nand2tetris\\tools\\builtInChips\\PC.hdl. Note the priority: reset first, then load, inc at last. The &gt;&gt; button can tick the clock automatically every second.","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"Hello, Time!","slug":"Hello-Time","date":"2021-02-08T08:06:54.000Z","updated":"2022-11-20T08:04:49.225Z","comments":true,"path":"2021/02/08/Hello-Time/","link":"","permalink":"https://adahuangsx.github.io/2021/02/08/Hello-Time/","excerpt":"","text":"Sequential Logic (Unit 3.1)In this unit we introduce the issue of time into the system, since we didn’t have the notion of change before. To simplify the concept, we divide time into atomic pieces, which is clock. Clock (Integer Time Unit)Clock can be viewed as an oscillator at a certain fixed rate, of which each cycle is treated as a time unit, like time 0, time 1 and so on. The signals are viewed as a indivisible thing as if nothing changes within each time unit. As a input signal is renewed every cycle, the output signal instantaneously follows (几乎同时). You may wonder if this is real. Indeed, there may be delay in physical electrical signals. But, we can think it as a way that the voltage change (the grey area in the screenshot below) happens between cycles, while luckily, the cycles are a little bit wider than this instability. So, it is safe to ignore it and focus on the end of each time unit. Also, (my guess) another reason may be given by the answer “Why binary?”. —&gt; it may takes time to reach the final and consistent stage but not necessarily precise but it’s already enough to tell zero from one. Combinatorial Logic Vs. Sequential LogicCombinatorial:$$out[t] = function(in[t])$$Above is what we learned in the previous units. Sequential:$$out[t] = function(in[t - 1])$$This is what we are going to talk about next. The above topic requires an element: Remembering State, so that the time unit t can response according to time unit t - 1. That means it has to be in two different physical states, which must be able to shift according to the logic of the previous time unit. Flip Flops(触发器) (Unit 3.2)Gates that can flip between 2 gates —&gt; Flip Flops D Flip Flop The little triangle represents this is a sequential chip. It is primitive in this course, like Nand Gate, the base of all other gates. It can be built from Nand Gate. It is a simple gate with “memory”. How to build the D Flip Flop?Steps: Create a loop which amplifying the same signal. Provide isolation between sequential time units. 再多的实现部分也不会在这个课上讲了…… Remember Forever把D触发器输出连回到输入，就能实现数据的维持了。在回去的时候通过一些Combinatorial Logic就能进行其他计算的操作了。 这个可以进一步整合成一个“register”。 1-Bit Register1234if (load(t - 1) &#x3D;&#x3D; true) out(t) &#x3D; in(t - 1) &#x2F;&#x2F; Load in else out(t) &#x3D; out(t - 1) &#x2F;&#x2F; maintain Once we work out the 1-bit memory, we can build the much larger memory.","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"Project 2: Boolean Arithmetic","slug":"project2","date":"2021-02-07T01:38:22.000Z","updated":"2022-11-20T08:04:49.228Z","comments":true,"path":"2021/02/07/project2/","link":"","permalink":"https://adahuangsx.github.io/2021/02/07/project2/","excerpt":"","text":"Previous TopicThe previous post has elaborated 3 things we need to implement: Half Adder, Full Adder and 16-bit Number Adder. The next is a simpler one: 16-bit Incrementor. Other Two Chips16-bit IncrementorTip: A single bit “0” or “1” can be represented by true or false in HDL. ALUTips: This can be built with the chips in Project 1 Only less than 20 lines of HDL code are needed. No need to use my own implementation in Project 1, but instead, the best practice is to use their built-in versions. (Make sure to use them like “Mux” or “And” precisely, because the simulator always looks for the chips in the current directory, and then if finds nothing, it will kick in and use the automatic built-in version at last.) Some Questions This WeekQ. We have built nearly 20 chips. Are they standard? or are they typically used in the computer systems?A. Yes, the gates this week like Half Adder and Full Adder are standard, as well as the 16 chips built in the last project like “Mux” and “Xor”, except ALU, which is extremely simplified from the actually used one. So, this ALU is a bit unique among usual ALUs. Q. How does the ALU we built operates multiplication and division?A. There is no problem to write HDL code that specifies chips to carry out these operations by working directly on bits. In fact, there are some elegant algorithms to do that. Designers are free to decide how much functionality to put into each layers. In this course, we put multiplication and division into the software that runs on the top of the computer to keep ALU simple. Also, this is another trade-off since hardware functionality runs much faster but costly. However, the high-level programmers will not feel this difference. Q. Is the ALU efficient?A. Almost everything we build is efficient, but some optimization is still possible. For example, the adder. Say there is a 32-bit adder, and to compute all the 32 bits, we need to connect all of the 32 Full Adders with the carries along the significance ladder. But don’t forget that a Full Adder is made of 3-4 other chips. So, the total delay would be $32 * 3 $. One optimization is the carry that goes one of the Full Adders at the top. We can, instead, compute this MSB carry in a more efficient way. This is called “carry look ahead”. Q. Why using the built-in chips, not the ones we built in the Project 1?A. You are more than welcomed to use them. However, using built-in chips is good for unit-testing and prevent the bugs from being messed up. While doing it （感想及常见错误）这次的作业感觉就是上次的延伸。只有5个chip，而且是前4个adder层层递进。 最后一个ALU是难点，重要的是要把上一次作业的chips利用起来。比如对于zx或nx，如何通过一个bit是零还是壹而输出不同的值，则应该想到Mux（多路器）。 还有仍然要小心”sub-bus“的错误，那就是[xx..xx]只能出现在..., out=out) 中的等号左边而不能pipe到其他chip的(in=...,)里，而形如..., out=out[0..7])则会报Sub bus of an internal node may not be used的错误。例子如下： 123SomeGate(..., out=foo);Or8Way(in=foo[0..7], out=p1);Or8Way(in=foo[8..15], out=p2); // ERROR 这样是不对的，因为foo是个中间产生的变量名，它在HDL中不能用sub-bus的方式作为另一个chip的“in=”。 Instead， 1234SomeGate(..., out[0..7]=foo1);SomeGate(..., out[8..15]=foo2);Or8Way(in=foo1, out=p1);Or8Way(in=foo2, out=p2); 应该像上面这样把2个narrower buses分别输出。代码的意思是“foo1接收了out的[0..7]位并被赋值成了8-bit的值”。 也可以像这样把多个narrowing合并起来： 1SomeGate(..., out[0..7]=foo1, out[8..15]=foo2); 以上可以参照Survival Guide 中的“sub-busing”部分。 Reference Project 2 Main page The HDL Guide The Hack Chip Set API","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"},{"name":"Projects","slug":"Projects","permalink":"https://adahuangsx.github.io/tags/Projects/"}]},{"title":"Arithmetic Logic Unit (ALU)","slug":"Binary-ALU","date":"2021-02-06T01:26:15.000Z","updated":"2022-11-20T08:04:49.224Z","comments":true,"path":"2021/02/06/Binary-ALU/","link":"","permalink":"https://adahuangsx.github.io/2021/02/06/Binary-ALU/","excerpt":"","text":"Adding two numbers in binary representation is pretty simple. Here we are gonna build an Adder for binary numbers. Starter (Unit 2.2)Why does the Adder matter most?Adder + Negative representation = Subtraction Multiplication and Division are not hardware’s work, but software’s. Three steps to build an Adder Half Adder: adds 2 bits Full Adder: adds 3 bits (used in “carry a 1”) Adder: adds 2 numbers Half Adder: adds 2 bitsWhen we focus on a single slice of bits adding, like “1 + 1”, it has 2 outputs: a carry bit “1” and a result bit “0”. a b sum(Xor) carry(And) 0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 CHIP HalfAdder is the first thing we need to implement in Project 2. Full Adder: adds 3 bitsThe last Half Adder is only for the case when carry is “0”, while Full Adder includes adding the carry and 2 bits together. a b c sum carry 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 Tip: A Full Adder can be built with 2 Half Adders. Adder: adds 2 numbersAssuming the numbers are 16-bit long, we can implement it by connecting 16 Full Adders or 15 Full Adders and 1 Half Adder for the right-most bits. Tips: The carry bit is “piped” up the significance ladder, from right to left. The MSB carry bit should be ignored. Negative Numbers2’s complement is elegant, and it enables us to do subtraction (negative addition) exactly the same way as addition. Computing “-x”By solving this, we can deal with subtraction! So, no more hardware needed for it!~$$-x = 2^n-x = 1 + (2^n - 1) - x$$Why converting this way? Because $(2^n-1) $ is “all ones”, which makes subtraction very easy (no need to borrow anything!). —&gt; JUST FLIP THE BITS of $x$ Then, add one. —&gt; easy. Negation steps in one word: Flip all the bits; Add one. ALU (Unit 2.4)Where is ALU? Let’s take a close look into the computer: Von Neumann Architecture$$Computer System = Input + Memory + (Control + ALU) + Output$$ In which,$$Control + ALU = CPU (Central Processing Unit)$$ The Hack ALU The 6 control bits represent which function to compute. zr and ng will be clear later. Open the ALU Black BoxControl bits (blue circle in the last image): zx if (zx) then x = 0 nx if (nx) then x = !x zy if (zy) then y = 0 ny if (zy) then y = !y f if (f) then out=x + y else out = x &amp; y no if (no) then out = !out These 6 control bits work one after another (按顺序进行操作). 比如zx 和 nx都是 “0”，那么就是让x不做任何操作，保持原样。如果zx 是 nx都是 “1”，那么就是先转为 “0”，再取反，就是把x各位都转化为 “1”。 Some QuestionsQ. How does this magically happened? It didn’t do the addition or subtraction as we learned earlier 0 0A. We don’t want to get too much into it… Q. 6 control bits can have $2^6 $ representations, why are there only 16 functions?A. Try out some other combinations, you will find them produce nothing interesting. Q. What are zr and ng designed for?A. They are to say something about the main output out. if (out == 0) then zr = 1 else zr = 0if (out &lt; 0) then ng = 1 else ng = 0 Simplicity is the ultimate sophistication. ——Leonardo da Vinci","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"Binary and Arithmetic","slug":"Binary-and-arithmetic","date":"2021-02-05T11:08:31.000Z","updated":"2022-11-20T08:04:49.225Z","comments":true,"path":"2021/02/05/Binary-and-arithmetic/","link":"","permalink":"https://adahuangsx.github.io/2021/02/05/Binary-and-arithmetic/","excerpt":"","text":"Binary and Arithmetic (Unit 2.1)Adding two numbers in binary representation is pretty simple. Here we are gonna build an Adder for binary numbers. Why does the Adder matter most?Adder + Negative representation = Subtraction Multiplication and Division are not hardware’s work, but software’s. Three steps to build an Adder Half Adder: adds 2 bits Full Adder: adds 3 bits (used in “carry a 1”) Adder: adds 2 numbers Half Adder: adds 2 bitsWhen we focus on a single slice of bits adding, like “1 + 1”, it has 2 outputs: a carry bit “1” and a result bit “0”. (truth table) (chip code) CHIP HalfAdder is the first thing we need to implement in Project 2. Full Adder: adds 3 bitsThe last Half Adder is only for the case when carry is “0”, while Full Adder includes adding the carry and 2 bits together. (truth table) (chip code) Adder: adds 2 numbersAssuming the numbers are 16-bit long, we can implement it by connecting 16 Full Adders or 15 Full Adders and 1 Half Adder for the right-most bits. Negative Numbers2’s complement is elegant, and it enables us to do subtraction (negative addition) exactly the same way as addition. Computing “-x”By solving this, we can deal with subtraction! So, no more hardware needed for it!~$$-x = 2^n-x = 1 + (2^n - 1) - x$$Why converting this way? Because $(2^n-1) $ is “all ones”, which makes subtraction very easy (no need to borrow anything!). —&gt; JUST FLIP THE BITS Then, add one. —&gt; easy. Negation steps in one word: Flip all the bits; Add one.","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"Project 1: Boolean Logic","slug":"project1","date":"2021-01-25T14:08:14.000Z","updated":"2022-11-20T08:04:49.228Z","comments":true,"path":"2021/01/25/project1/","link":"","permalink":"https://adahuangsx.github.io/2021/01/25/project1/","excerpt":"","text":"Project 1 Goal (Unit 1.8)Given a NAND, build all the gates. 课上给了Project 1的其中几个chips的讲解。讲了Mux, DMux, And16 和 Mux4Way16。 Project 1 OverviewMultiplexor (多路器) or Mux1234567IN a, b, sel // &quot;sel&quot; means &quot;selection bit&quot;.OUT outif (sel == 0) out = aelse out = b Tip: You can build with AND, OR, NOT gates. Example: AndMuxOr1234567IN a, b, selOUT outif (sel == 0) out = a AND belse out = a OR b Tip: 这个可以很容易用Mux做出来。 Demultiplexor(分路器) or DeMuxIt is like the “inverse” of Mux. 1234567IN in, selOUT a, bif (sel == 0) (a, b) = (in, 0)else (a, b) = (0, in) Note: 以上两个都在communication networks中经常使用。比如Mux和DMux之间就可能是一个海底光缆的单线信息流，两头分别进行汇总和分流。如下图： 这里的sel就是oscillator（振荡器）。 这样做可以减少昂贵的物理传输费用，还可以做到encoding和decoding异步进行。 And16Tip: 16个bit是无顺序可言的，就像同时放出来的一样。 Mux4Way16123IN a[16], b[16], c[16], d[16], sel[2];OUT out[16];// &#x27;sel&#x27; has 2 bits to represent 4 ways. Some tips for this assignment 尽量按顺序完成，这样后面的就可以用到前面写好的helper chips。 不按顺序也可以，但是当用到一个没写好的chip比如chip AND &#123;&#125;，可以把文件名临时改成And.hdl233。这样系统会自动调用内建的chip。 chip不能调用自己。 记得看HDL Survival Guide 和各种资源！ VSCode 居然有Nand2Tetris的专门编辑.hdl文件的插件。 Some tips when doing it 变量名不要用下划线！（别问我怎么知道的……） 参考资料 Hardware Simulator Tutorial HDL Survival Guide 其他资源在这里，大都是google doc的","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"},{"name":"Projects","slug":"Projects","permalink":"https://adahuangsx.github.io/tags/Projects/"}]},{"title":"Hardware simulator","slug":"hardware-simulator","date":"2021-01-23T14:15:40.000Z","updated":"2022-11-20T08:04:49.227Z","comments":true,"path":"2021/01/23/hardware-simulator/","link":"","permalink":"https://adahuangsx.github.io/2021/01/23/hardware-simulator/","excerpt":"","text":"这两个单元主要是介绍了软件怎么用，怎么test和生成output。简介了Hardware Description Language (HDL) (unit 1.4) Hardware simulator (unit 1.5)Feel free to “kick the tires”! The simulator is written in Java. The download link is here. The simulator is invoking in nand2tetris/tools/HardwareSimulator.bat. It can check both output pins and internal pins. Script-based simulationHDL code .hdl + test script tst —–&gt; into simulator —–&gt; Output file .out Note that this way to debug by checking the output file is rare in real life testing, because a real chip is far more complex than an Xor chip. A more systematic and planned method is going to be introduced next. Script-based simulation with compare filesThe compare file .cmp, whose previous incarnation (前身) is a correct output file. Hardware Construction Projects System architects chip API test script compare file Developers build the chip with HDL In this course, we play the role of developers. Multi-Bit Buses“Bus” means “many” in Latin. Some Syntax NotesSay, an integer is aaa[16]: aaa is the integer’s name aaa[0] is its first bit. （注意是LSB，就是最低位/最右边的一位。） aaa[7..15], with 2 dots in the middle, means its sub-bus. Other syntaxes: true and false can represent a bus with constant signal of any width. 补充一个后面答疑问到的几个关于HDL的问题： Q. 这门课中的HDL语言是现实中使用的吗？A. 很相似，比如和VHDL相比，VHDL可能在基本的HDL基础上加了一些类C的语言，比如For这些。（所以code block我也就近用了VHDL的高亮）","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"Why Nand? -- starting Nand2Tetris part I","slug":"Why-Nand","date":"2021-01-23T05:25:32.000Z","updated":"2022-11-20T08:04:49.226Z","comments":true,"path":"2021/01/23/Why-Nand/","link":"","permalink":"https://adahuangsx.github.io/2021/01/23/Why-Nand/","excerpt":"","text":"这一章除了复习了一遍以前学过的与非或逻辑门，还介绍了为什么一个与非门就能表示所有的逻辑表达式。 Boolean logic (unit 1.1 – 1.3)Algebra rules Commutative laws x AND y == y AND x x OR y == y OR x Associative laws x AND (y AND z) == (x AND y) AND z x OR (y OR z) == (x OR y) OR z Distributive laws x AND (y OR z) == (x AND y) OR (x AND z) x OR (y AND z) == (x OR y) AND (x OR z) De Morgan laws NOT (x AND y) == NOT (x) OR NOT (y) NOT (x OR y) == NOT (x) AND NOT (y) Other rules x AND x == x x OR x == x Truth table to Boolean Expression Focus all the “1” results write down all the expressions which only apply to the single rows in the truth table OR these expressions together Simplify it. In the example above, give a close look at the first two clauses: we have both possibilities for “y” and the same fixed value for “x”. So, we can combine the two clauses, which does not ask about y and only ask about “NOT(x)” and “NOT(z)”. Then keep doing this. Note that finding the shortest expressions is not easy for humans nor for algorithms, because this is a NP-hard problem. To prove Why-NandThe TheoremAny Boolean function can be represented using an expression only containing AND and NOT operations. Then, we introduce the NAND gate, which is proved to be the only needed gates. Here comes the Nandx NAND y == NOT (x AND y) “NAND” is short for “NOT AND”. Nand takes over. NOT (x) == x NAND x x AND y == NOT (x NAND y) The gate interface in unique. There is only one way to describe its functionality. Meantime, there are multiple implementations that realize the same obstruction. This duality of “one obstruction, many different implementations” is very typical in Computer Science. 所以这里解答了我对计算机的一个疑问，那就是不必纠结一个复杂的功能最底层到底是怎么实现的，而是像这门课一样，分层地理解。了解了一层以后，就把这层的知识作为已知，再去了解上面一层。 补充一个后面答疑问到的几个关于Nand的问题： Q. 用NAND以外别的gate做计算机的基础行不行？A. 当然可以，比如NOR (NOT OR)。这就像物理中用不同的坐标系一样。只不过NAND相比于其他gate造价相对便宜。 Q. 这门课直接把Nand拿来用，但是黑盒里面是怎么实现的呢？A. 这更像是一个物理问题，不属于这门课的范围。但是很容易举出一个实现的例子：用NMOS实现与非门电路 References Nand2Tetris home page Nand2Tetris Coursera link","categories":[{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"}]},{"title":"IR Project -- Movie Script Search","slug":"IS2140-IR-finalproject","date":"2020-12-10T06:28:28.000Z","updated":"2022-11-20T08:04:49.226Z","comments":true,"path":"2020/12/10/IS2140-IR-finalproject/","link":"","permalink":"https://adahuangsx.github.io/2020/12/10/IS2140-IR-finalproject/","excerpt":"","text":"IntroductionThis is the final project of INFSCI 2140 Information Storage and Retrieval. We built a search engine of movie lines. Users can input a phrase or a complete sentence and it returns a list of best matched movies with excerpts. Teammates Zijian Xu Long Yan Data Sourcehttps://nlds.soe.ucsc.edu/fc2 Film Corpus 2.0 It contains 960 film scripts including dialogues and scene descriptions. Tools Backend: Spring MVC Frontend: Angular 7 Cloud &amp; Deployment: Microsoft Azure Cloud Library: Apache Lucene ImplementationData Processing Remove space lines and special characters Tokenize and normalize the terms with Porter Stemming Data Pipeline Indexing – Index Writer Fetch movie script documents from cloud Write index files with Lucene into RAM Run once with starting the server Searching – Index Reader Tokenize query words Search for the documents with Lucene Get surrogate fragments with Lucene highlighter Use CaseUsers input a phrase or sentence like “show me the money”, and our system outputs: ReferencesFilm Corpus Walker, Marilyn A., Ricky Grant, Jennifer Sawyer, Grace I. Lin, Noah Wardrip-Fruin, and Michael Buell. “Perceived or Not Perceived: Film Character Models for Expressive NLG.” BEST PAPER AWARD. In International Conference on Interactive Digital Storytelling (ICIDS), Vancouver, Canada, 2011. Marilyn A. Walker, Grace I. Lin, Jennifer E. Sawyer. “An Annotated Corpus of Film Dialogue for Learning and Characterizing Character Style.” In Proceedings of the 8th International Conference on Language Resources and Evaluation (LREC), Istanbul, Turkey, 2012.","categories":[{"name":"Projects","slug":"Projects","permalink":"https://adahuangsx.github.io/categories/Projects/"}],"tags":[{"name":"Search Engine","slug":"Search-Engine","permalink":"https://adahuangsx.github.io/tags/Search-Engine/"},{"name":"Java","slug":"Java","permalink":"https://adahuangsx.github.io/tags/Java/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"https://adahuangsx.github.io/tags/Spring-MVC/"},{"name":"Projects","slug":"Projects","permalink":"https://adahuangsx.github.io/tags/Projects/"}]}],"categories":[{"name":"DDIA","slug":"DDIA","permalink":"https://adahuangsx.github.io/categories/DDIA/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/categories/Nand2Tetris/"},{"name":"Projects","slug":"Projects","permalink":"https://adahuangsx.github.io/categories/Projects/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://adahuangsx.github.io/tags/Hexo/"},{"name":"Notes","slug":"Notes","permalink":"https://adahuangsx.github.io/tags/Notes/"},{"name":"DDIA","slug":"DDIA","permalink":"https://adahuangsx.github.io/tags/DDIA/"},{"name":"Coursera","slug":"Coursera","permalink":"https://adahuangsx.github.io/tags/Coursera/"},{"name":"Nand2Tetris","slug":"Nand2Tetris","permalink":"https://adahuangsx.github.io/tags/Nand2Tetris/"},{"name":"Projects","slug":"Projects","permalink":"https://adahuangsx.github.io/tags/Projects/"},{"name":"Search Engine","slug":"Search-Engine","permalink":"https://adahuangsx.github.io/tags/Search-Engine/"},{"name":"Java","slug":"Java","permalink":"https://adahuangsx.github.io/tags/Java/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"https://adahuangsx.github.io/tags/Spring-MVC/"}]}